---
title: "Operating System - Process(1)"
date: 2020-07-15
last_modified_at: 2020-07-28
desc: "OS 프로세스(1)"
keywords: "OS,Operating System,Process,프로세스"
permalink: "/os/process1"
categories: 
    - OS
tags: 
    - OS
    - Process
---

# 프로세스

비공식적으로 프로세스는 실행 중인 프로그램이다. 프로세스의 현재 활동의 상태는 프로그램 카운터(PC) 값과 프로세서 레지스터의 내용으로 나타낸다. 프로세스의 메모리 배치는 일반적으로 여러 섹션으로 구성되어 있으며 아래와 같다.

![imageProcess]({{ site.url }}{{ site.baseurl }}/assets/images/posts/image_os_process_01.jpg)

위의 이미지와 같이 프로세스는 아래와 같은 섹션들을 포함하고 있다.

* 힙 - 프로그램 실행 중에 동적으로 할당되는 메모리
* 스택 - 함수를 호출할 때 임시 데이터 저장장소(함수의 매개변수, 반환 주소, 지역 변수 등등)
* 데이터 - 전역 변수
* 텍스트 - 실행 코드

텍스트 및 데이터 섹션은 크기가 고정되어있기 떄문에 프로그램 실행 시간 동안 크기가 변하지 않는다. 그러나 힙, 스택 섹션은 프로그램 실행 중에 동적으로 변동된다.

## 힙, 스택

### 스택 

함수가 호출될 때마다 함수의 매개변수, 지역 변수 및 반환 주소를 포함하는 활성화 레코드(activiation record)가 스택에 푸쉬(PUSH) 된다. 함수로부터 제어가 되돌아오면 스택에서 활성화 레코드가 팝(POP) 된다.

### 힙

스택과 마찬가지로 메모리가 동적으로 할당됨에 따라 힙이 커지고 메모리가 시스템에 반환되면 축소된다.

스택 및 힙 섹션이 서로의 방향으로 커지더라도 운영체제는 서로 겹치지 않도록 조절해줘야 한다.

> 프로그램 그 자체는 프로세스가 아니다. 프로그램은 명령어 리스트를 내용으로 가진 디스크에 저장된 파일과 같은 수동적인 존재이다. 이와 반대로 프로세스는 다음에 실행할 명령어를 지정하는 프로그램 카운터와 관련 자원의 집합을 가진 능동적인 존재이다. **결론은 실행 파일이 메모리에 적재될 때 프로그램은 프로세스가 된다.**

## 프로세스 상태

프로세스는 실행되면서 상태가 수시로 변한다. 프로세스의 상태는 부분적으로 그 프로세스의 현재의 활동에 따라서 정의된다. 프로세스의 상태는 아래와 같다.

* 새로운(new) - 프로세스가 생성 중이다.
* 실행(running) - 명령어들이 실행되고 있다.
* 대기(waiting) - 프로세스가 어떤 이벤트가 일어나기를 기다린다.
* 준비(ready) - 프로세스가 프로세서에 할당되기를 기다린다.
* 종료(terminated) - 프로세스의 실행이 종료되었다.

> 상태의 이름은 운영체제마다 다르므로 임의적이다. 그렇지만, 모든 시스템에서 프로세스의 상태를 찾아볼 수 있다. 또한 어떤 운영체제는 프로세스의 상태를 더욱 자세하게 묘사하여 구별한다. **결론은 어느 한순간에 한 프로세서 코어에서 오직 하나의 프로세스만 실행된다는 것을 인식하는것이 중요하다.**

> 많은 프로세스가 준비완료 및 대기 상태에 있을 수 있다.

## 프로세스 제어 블록(PCB: Process Control Block)

각 프로세스는 운영체제에서 PCB에 의해 표현된다. PCB는 특정 프로세스와 연관된 여러 정보를 수록하며, 다음과 같은 것들을 포함한다.

* 프로세스 상태 - new, ready, running, waiting, halted 등이 있다.
* 프로그램 카운터 - 프로그램 카운터는 이 프로세스가 다음에 실행할 명령어의 주소를 가리킨다.
* CPU 레지스터들 - CPU 레지스터는 컴퓨터의 구조에 따라 다양한 수와 유형을 가진다. 레지스터에는 누산기, 인덱스, 스택, 범용 레지스터들과 상태 코드 정보가 포함된다. 프로그램 카운터와 함께 이 상태 정보는, 나중에 프로세스가 다시 스케줄 될 때 올바르게 실행되도록 하기 위해 인터럽트 발생 시 저장되어야 한다.
* CPU 스케줄링 정보 - 이 정보는 프로세스 우선순위, 스케줄 큐에 대한 포인터와 다른 스케줄 매개변수를 포함한다.
* 메모리 관리 정보 - 이 정보는 운영체제에 의해 사용되는 메모리 시스템에 따라 베이스, 리미트 레지스터의 값. 운영체제가 사용하는 메모리 시스템에 따라 페이지, 세그먼트 테이블 등과 같은 정보를 포함한다.
* 회계 정보 - 이 정보는 CPU 사용 시간과 경과된 실시간, 시간 제한, 계정 정보, 잡 또는 프로세스 번호 등을 포함한다.
* 입출력 상태 정보 - 이 정보는 이 프로세스에 할당된 입출력 장치들과 열린 파일의 목록 등을 포함한다.

**결론은 PCB는 약간의 회계 데이터와 함께 프로세스를 시작시키거나 다시 시작시키는 데 필요한 모든 데이터를 위한 저장소 역활을 한다.**

이미지는 아래와 같다.<br/>

![imageProcess]({{ site.url }}{{ site.baseurl }}/assets/images/posts/image_os_pcb.png)

## 스레드

앞에서 얘기한 프로세스는 단일 실행 스레드를 실행하는 프로그램임을 의미한다. 예를 들면, 만일 한 프로세스가 워드 프로세서 프로그램을 실행 중이면, 실행되는 명령어의 단일 스레드가 존재한다. 이 단일 제어 스레드는 프로세스가 한 번에 한가지 일만 처리할 수 있도록 허용한다. 따라서 사용자는 문자를 입력하면서 동시에 철자 검사기를 실행할 수 없다.

> 대부분의 현대 운영체제는 프로세스 개념을 확장하여 한 프로세스가 다수의 실행 스레드를 가질 수 있도록 허용한다. 따라서 프로세스가 한 번에 하나 이상의 일을 수행할 수 있도록 허용한다. 이러한 특성은 특히 멀티 코어 프로세서에서 이익을 얻을 수 있는데, 여러 스레드가 병렬로 실행될 수 있다.

## 프로세스 스케줄링

다중 프로그래밍의 목적은 CPU를 최대한 사용하기 위해 항상 어떤 프로세스가 실행 되도록 하는 데 있다. 

시분할의 목적은 각 프로그램이 실행되는 동안 사용자가 상호 작용할 수 있도록 여러개의 프로세스 사이에서 CPU 코어를 빈번하게 교체하는 것이다. 이를 위해 프로세스 스케줄러는 코어에서 실행 가능한 여러 프로세스 중에서 하나의 프로세스를 선택한다. 각 CPU 코어는 한 번에 하나의 프로세스만 실행할 수 있다. 단일 CPU 코어 시스템의 경우 한 번에 2개 이상의 프로세스가 실행될 수 없지만 다중 코어 시스템은 한 번에 여러 프로세스를 실행할 수 있다. 코어보다 많은 프로세스가 있는 경우 초과 프로세스는 코어가 사용 가능해지고 다시 스케줄 될 때까지 기다려야 한다. 

현재 메모리에 있는 프로세스 수를 **다중 프로그래밍 정도**라고 한다. 다중 프로그래밍 및 시간 공유의 목표를 균형 있게 유지하려면 프로세스의 일반적인 동작을 고려해야 한다. 일반적으로 대부분의 프로세스는 IO 바운드 또는 CPU 바운드로 설명할 수 있다.

IO 바운드 프로세스 - 계산에 소비하는 것보다 IO에 더 많은 시간을 소비하는 프로세스이다.</br>
CPU 바운드 프로세스 - 계산에 더 많은 시간을 사용하여 IO 요청을 자주 생성하지 않는다.

### 스케줄링 큐

프로세스가 시스템에 들어가면 준비 큐에 들어가서 준비 상태가 되어 CPU 코어에서 실행되기를 기다린다. 이 큐는 일반적으로 연결 리스트로 저장된다. 준비 큐 헤더에는 리스트의 첫 번째 PCB에 대한 포인터가 저장되고 각 PCB에는 준비 큐의 다음 PCB를 가리키는 포인터 필드가 존재한다.

시스템에는 다른 큐도 존재한다. 프로세스에 CPU 코어가 할당되면 프로세스는 잠시 동안 실행되어 결국 종료되거나 인터럽트 되거나 IO요청의 완료와 같은 특정 이벤트가 발생할 때까지 기다린다. 프로세스가 디스크와 같은 장치에 IO 요청을 한다고 가정하자. 디스크와 같은 장치는 프로세서보다 상당히 느리게 실행되므로 프로세스는 IO가 가능할 때까지 기다려야 한다. IO 완료와 같은 특정 이벤트가 발생하기를 기다리는 프로세스는 대기 큐에 삽입된다.

![imageProcess]({{ site.url }}{{ site.baseurl }}/assets/images/posts/image_os_ready_queue_wait_queue.jpg)

프로세스 스케줄링의 일반적인 표현은 아래의 그림과 같은 큐잉 다이어그램이다. 준비 큐와 대기 큐의 집합의 두 가지 유형의 큐가 있다. 원은 큐에 서비스를 제공하는 **자원**을 나타내고 화살표는 시스템의 **프로세스의 흐름**을 나타낸다. 새 프로세스는 처음에 준비 큐에 놓인다. 프로세스는 실행을 위해 선택되거나 또는 디스패치 될 때까지 기다린다. 프로세스에 CPU 코어가 할당되고 실행 상태가 되면, 여러 이벤트 중 하나가 발생할 수 있다.

* 프로세스가 IO 요청한 다음 IO 대기 큐에 놓일 수 있다.
* 프로세스는 새 자식 프로세스를 만든 다음 자식의 종료를 기다리는 동안 대기 큐에 놓일 수 있다.
* 인터럽트 또는 타임 슬라이스가 만료되어 프로세스가 코어에서 강제로 제거되어 준비 큐로 돌아갈 수 있다.

> 처음 두 경우에는 프로세스가 결국 대기 상태에서 준비 상태로 전환된 다음 준비 큐에 다시 들어간다. 프로세스는 종료될 때까지 이 주기를 계속한다. 종료 시점에 모든 큐에서 제거되고 PCB 및 자원이 반환된다.

![imageProcess]({{ site.url }}{{ site.baseurl }}/assets/images/posts/image_os_wait_for_process_schedule.png)


### CPU 스케줄링

프로세스는 수명주기 동안 준비 큐와 다양한 대기 큐를 이주한다. CPU 스케줄러의 역할은 준비 큐에 있는 프로세스 중에서 선택된 하나의 프로세스에 CPU 프로세서를 할당한다. CPU 스케줄러는 CPU를 할당하기 위한 새 프로세스를 자주 선택해야 한다. IO 바운드 프로세스는 IO 요청을 대기하기 전에 몇 밀리초 동안만 실행할 수 있다. CPU 바운드 프로세스에는 오랜 시간 동안 CPU 코어가 필요하지만 스케줄러는 프로세스에게 코어를 장기간 부여할 가능성이 없다. 대신 프로세스에서 CPU를 강제로 제거하고 실행될 다른 프로세스를 스케줄 하도록 설계될 가능성이 높다. 따라서 CPU 스케줄러는 일반적으로 훨씬 더 자주 실행되지만 적어도 100밀리초마다 한 번씩 실행된다.

> 일부 운영체제는 스와핑이라고 알려진 중간 형태의 스케줄링을 가지고 있는데, 핵심 아이디어는 **때떄로 메모리에서 프로세스를 제거하여 다중 프로그래밍 정도를 감소시키는 것이 유리할 수 있다는 것이다.** 나중에 프로세스를 메모리에 다시 적재할 수 있으며 중단된 위치에서 실행을 계속할 수 있다. 프로세스를 메모리에서 디스크로 __스왑아웃__ 하여 현재 상태를 저장하고, 이후 디스크에서 메모리로 __스왑인__ 하여 상태를 복원할 수 있기 때문이 기 법을 스와핑이라고 한다. 

>> 스와핑은 일반적으로 메모리가 초과 사용되어 가용공간을 확보해야 할 때만 필요하다.

### 문맥 교환

> 인터럽트는 운영체제가 CPU 코어를 현재 작업을 중단시키고 새로운 커널 루틴 작업을 실행할 수 있게 한다.

인터럽트는 범용 시스템에서 자주 발생한다. 인터럽트가 발생하면 시스템은 인터럽트 처리가 끝난 후에 문맥을 복구할 수 있도록 현재 실행 중인 프로세스의 문맥을 저장할 필요가 있다. 이는 결국 프로세스를 중단했다가 재개하는 작업이다.

문맥은 프로세스의 PCB에 표현된다. 문맥은 CPU 레지스터의 값, 프로세스의 상태, 메모리 관리 정보 등을 포함한다. 일반적으로 커널 모드이건 사용자 모드이건 CPU의 현재 상태를 저장하는 작업을 수행하고, 나중에 연산을 재개하기 위해 상태 복구 작업을 수행한다.

> CPU 코어를 다른 프로세스로 교환하려면 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 보관된 상태를 복구하는 작업이 필요한데, 이 작업을 문맥 교환이라고 한다. 

문맥 교환이 일어나면, 커널은 과거 프로세스의 문맥을 PCB에 저장하고, 스케줄된 새로운 프로세스의 저장된 문맥을 복구한다. 문맥 교환이 진행될 동안 시스템이 아무런 유용한 일을 못 하기 때문에 문맥 교환 시간은 순수한 오버헤드이다. 교환 속도는 메모리의 속도, 반드시 복사되어야 하는 레지스터의 수, 특수 명령어의 존재에 좌우되므로, 기계마다 다르다. 문맥 교환 시간은 하드웨어의 지원에 크게 좌우된다. 예를 들어, 일부 처리기들은 여러 개의 레지스터 집합을 제공한다. 문맥 교환은 단순히 현행 레지스터 집합에 대한 포인터를 변경하는 것을 포함한다. 물론, 레지스터 집합들보다도 활성 프로세스들이 더 많다면, 시스템은 전처럼 레지스터 자료를 메모리로 또는 메모리에서 복사해야 한다. 또한 운영체제가 복잡할수록, 문맥 교환 시 해야 할 작업의 양이 더 많아진다. 

* 고급 메모리 관리 기법을 사용하면 문맥 교환 시 더 많은 자료들을 교환해야 한다.

![imageProcess]({{ site.url }}{{ site.baseurl }}/assets/images/posts/image_os_context_change.png)

## 프로세스에 대한 연산

대부분의 시스템 내의 프로세스들은 병렬 실행될 수 있으며, 반드시 동적으로 생성되고, 제거되어야 한다. 그러므로 운영체제는 프로세스 생성 및 종료를 위한 기법을 제공해야 한다. 

### 프로세스 생성

프로그램이 실행되는 동안 프로세스는 여러 개의 새로운 프로세스들을 생성할 수 있다. 생성하는 프로세스를 부모 프로세스라고 부르고, 새로운 프로세스는 자식 프로세스라고 부른다. 이 새로운 프로세스들은 각각 다른 프로세스들을 생성할 수 있다. 그 결과 프로세스의 **트리**를 형성한다.

UNIX, Linux, Window와 같은 현대 운영체제들은 **pid**를 사용하여 프로세스를 구분하는데 이 식별자는 보통 정수이다. pid는 시스템의 각 프로세스에 고유한 값을 가지도록 할당한다. pid를 통해 커널이 유지하고 있는 프로세스의 다양한 속성에 접근하기 위한 인덱스로 사용된다. 

아래의 그림은 Linux 운영체제의 전형적인 프로세스 트리를 보여 주고 있으며 프로세스 이름과 pid를 보여준다. 언제나 pid가 1인 systemd 프로세스가 모든 사용자 프로세스의 루트 프로세스 역활을 수행하고 시스템이 부트될 때 생성되는 **첫 번째 사용자 프로세스**이다. 시스템이 부팅되면 systemd 프로세스는 다양한 사용자 프로세스를 생성한다. 

![imageProcess]({{ site.url }}{{ site.baseurl }}/assets/images/posts/image_os_process_tree.png)

이러한 프로세스에는 웹, 프린트 서버, ssh 서버 등이 포함된다. 아래의 그림에서 systemd의 두 자식 프로세스 logind와 sshd 프로세스를 볼 수 있다. 

* **logind 프로세스**는 시스템에 직접 로그인하는 클라이언트를 관리하는 책임을 진다. 이 예제에서 클라이언트는 로그인한 후 bash 셸을 사용하고 있는데, 셸의 pid는 8416이 할당되었다. bash 명령어 라인 인터페이스를 사용하여 이 사용자는 ps 프로세스와 vim 편집기 프로세스를 생성하였다.

* **sshd 프로세스**는 ssh을 사용하여 시스템에 접속하는 클라이언트 관리를 책임진다.

UNIX와 Linux 시스템에서는 ps 명령어를 이용하여 프로세스들의 목록을 얻을 수 있다. 예를 들어 다음과 같은 명령은 현재 시스템에 활성화되어 있는 모든 프로세스의 정보를 나열해 줄 것이다. 

> 프로세스들의 부모 프로세스를 systemd가 나올 때까지 재귀적으로 추적하면 위의 그림과 유사한 프로세스 트리를 구축하는 것은 쉽다.

```
ps -el
```

일반적으로 프로세스가 자식 프로세스를 생성할 때, 그 자식 프로세스는 자신의 임무를 달성하기 위해 어떤 자원(CPU 시간, 메모리, 파일, 입출력 장치)이 필요하다. 자식 프로세스는 이 자원을 운영체제로부터 직접 얻거나, 부모 프로세스가 가진 자원의 일부분을 사용하도록 제한될 수 있다. 부모 프로세스는 자원을 분할하여 자식 프로세스들에게 나누어 주거나 메모리나 파일과 같은 몇몇 자원들은 자식 프로세스들이 같이 사용하도록 할 수 있다. 부모 프로세스 자원의 일부분만 자식 프로세스가 쓸 수 있게 제한하며, **자식 프로세스를 많이 생성하여 시스템을 과부하 상태로 만드는 프로세스를 방지할 수 있다.**

물리적, 논리적 자원을 제공하는 것 이외에 부모 프로세스는 자식 프로세스에 초기화 데이터를 전달할 수 있다. 예를 들어, hw1.c라는 파일의 내용을 단말기의 화면에 나타내는 기능을 가진 프로세스를 생각해 보자. 이 프로세스가 생성될 때, 부모 프로세스로부터 입력 데이터로 hw1.c라는 파일 이름을 얻을 수 있으며, 이 파일 이름을 사용하여 파일을 열고 내용을 출력할 수 있다. 프로세스는 또한 출력 장치의 이름도 전달받을수 있을 것이다. 대체 방안으로, 어떤 운영체제는 자식 프로세스에 자원을 전달한다. 이와 같은 시스템에서 새로운 프로세스는 hw1.c와 터미널 장치에 해당하는 두 개의 열린 파일을 전달받고 단순히 두 장치 사이에서 데이터를 전송하는 작업만 하면 된다. 

프로세스가 새로운 프로세스를 생성할 때, 두 프로세스를 실행시키는 데 두 가지 가능한 방법이 존재한다.
* 부모는 자식과 병렬로 실행된다.
* 부모는 일부 또는 모든 자식이 실행을 종료할 때까지 기다린다.

새로운 프로세스들의 __주소 공간__ 측면에서 볼 때 다음과 같은 두 가지 가능성이 있다.
* 자식 프로세스는 부모 프로세스의 복사본이다.(자식이 부모와 똑같은 프로그램과 데이터를 가진다.)
* 자식 프로세스가 자신에게 적재될 새로운 프로그램을 가지고 있다.

이들의 차이점을 설명하기 위해서, 우선 UNIX 운영체제를 고려해 보자. UNIX에서 각 프로세스는 유니크한 정수값으로 이루어진 프로세스 식별자로 확인할 수 있다. 새로운 프로세스는 __fork()__ 시스템 콜로 생성된다. 새로운 프로세스는 원래 프로세스의 주소 공간의 복사본으로 구성된다. 이 기법은 부모 프로세스가 쉽게 자식 프로세스와 통신할 수 있게 한다. 두 개의 프로세스들은 fork() 후의 명령어에서부터 실행을 계속하며, 이때 한 가지 다른점은 fork()의 반환 코드가 서로 다르다는 것이다. 0이 아닌 자식 프로세스의 식별자가 부모로 반환되는 데 반해, 자식 프로세스는 0이 반환된다. 

fork() 시스템 콜 다음에 두 프로세스 중 한 프로세스가 __exec()__ 시스템 콜을 사용하여 자신의 메모리 공간을 새로운 프로그램으로 교체한다. exec() 시스템 콜은 이진 파일을 메로리로 적재하고 그 프로그램을 시작한다. 이와 같은 방법으로 두 프로세스는 통신할 수 있으며, 그 후 각자의 길을 간다. 그 후 부모는 더 많은 자식을 생성할 수 있으며, 자식이 실행하는 동안 부모 프로세스는 할 일이 없으면, 자식이 종료될 때까지 준비 큐에서 자신을 제거하기 위해 __wait()__ 시스템 콜을 호출한다. exec() 시스템 콜을 호출하면 프로세스의 주소 공간을 새 프로그램으로 덮어쓰기 때문에 exec() 시스템 콜은 오류가 발생하지 않는 한 제어를 반환하지 않는다.

아래의 코드는 앞에서 설명한 UNIX 시스템 콜을 C 프로그래밍 언어를 이용하여 구현한 것이다. 우리는 이제 동일한 프로그램 복사본을 실행하는 두 개의 서로 다른 프로세스를 갖는다. 유일한 차이점은 자식 프로세스에 보이는 pid의 값은 0이고, 반면에 부모 프로세스에게 보이는 pid 값은 0보다 큰 정수 값 이라는 것이다. 자식 프로세스는 열린 파일과 같은 자원뿐 아니라 특권과 스케줄링 속성을 부모 프로세스로부터 상속받는다. 그런 후 자식 프로세스는 __execlp()__ 시스템 콜을 사용하여 자신의 주소 공간을 UNIX 명령 /bin/ls로 덮어쓴다. 부모는 wait() 시스템 콜로 자식 프로세스가 끝나기를 기다리며, 자식 프로세스가 끝나면 부모 프로세는 wait() 호출로부터 재개하여, exit() 시스템 콜을 사용하여 프로세스를 끝낸다. 물론 자식 프로세스가 exec()를 호출하지 않고 부모 프로세스의 복사본을 계속 실행하는 것을 막을 방법은 없다. 이 시나리오에서 부모와 자식은 같은 코드를 실행하는 병행 프로세스이며, 자식은 부모의 복사본이기 때문에 각 프로세스는 모든 데이터에 대해 자신만의 복사본을 가지고 있다.

```c
#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid;
    pid = fork()

    if (pid < 0) { /* 오류 발생 */
        fprintf(stderr, "Fork Error")
        return 1;
    } else if (pid == 0) { // 자식 프로세스
        execlp("/bin/ls", "ls", NULL);
    } else {
        wait(NULL)
        printf("Child Complete")
    }

    return 0
}
```

![imageProcess]({{ site.url }}{{ site.baseurl }}/assets/images/posts/image_os_process_create_using_fork.png)

## 프로세스 종료

프로세스가 마지막 문장의 실행을 끝내고, exit 시스템 콜을 이용하여 운영체제에 자신의 프로세스 종료 요청을 보내면 종료된다. 이 시점에 프로세스는 자신을 기다리고 있는 부모 프로세스의 상태 값을 반환할 수 있다. 물리 메모리와 가상 메모리, 열린 파일, 입출력 버퍼를 포함한 프로세스의 모든 자원이 해제되고 운영체제로 리턴된다.

프로세스 종료가 발생하는 다른 경우가 있다. **한 프로세스는 적당한 시스템 콜을 통해서 다른 프로세스의 종료를 유발할 수 있다.** 통상적으로, 그런 시스템 콜은 단지 종료될 프로세스의 부모만 호출할 수 있으며, 만약 그렇지 않으면 사용자 또는 오작동하는 프로세스가 다른 사용자의 프로세스를 임의로 중단 시킬수 있을 것이다. 부모가 자식을 종료시키기 위해서는 자식의 pid를 알아야 한다. 부모 프로세스가 자식 프로세스를 만들 때 자식 프로세스의 id가 부모에게 전달된다. 부모는 아래와 같은 이류로 자식 중 하나의 실행을 종료할 수 있다.

* 자식이 자신에게 할당된 자원을 초과하여 사용할 때.
* 자식 프로세스가 더이상 필요 없을 때
* 부모가 exit를 하는데, 운영체제는 부모 프로세스가 종료된 후 자식 프로세스가 활동하는 것을 허용하지 않을 때

몇몇 시스템에서는 부모 프로세스가 종료된 후 자식 프로세스가 존재할 수 없다. 그러한 시스템에서는 부모 프로세스가 종료되면 자식 프로세스들도 같이 종료되어야 한다. 이것을 __연쇄식 종료(cascading termination)__ 이라고 하며, 이 작업은 운영체제가 수행한다.

예를 들어보자 Linux 운영체제에서 exit() 시스템 콜을 이용하여 프로세스를 종료할 수 있다. 이때 exit() 시스템 콜은 종료 상태를 나타내는 인자를 전달 받는다.

```c
// 1인 상태로 종료
exit(1)
```

사실 정상적인 종료에서 exit() 시스템 콜은 위와 같이 직접적으로 호출 되거나 UNIX 실행 파일에 추가되는 C 런타임 라이브러리가 디폴트로 exit() 시스템 콜을 추가하기 때문에 간접적으로 호출될 수 있다. 

부모 프로세스는 wait() 시스템 콜을 이용하여 자식 프로세스가 종료할 때를 기다릴 수 있다. wait() 시스템 콜은 부모가 자식의 종료 상태를 얻어낼 수 있도록 하나의 인자를 전달받는다. 이 시스템 콜은 부모가 어느 자식이 종료되었는지 구별할 수 있도록 종료된 자식의 프로세스 식별자를 반환한다.

```c
pid_t pid;
int status;

pid = wait(&status)
```

프로세스가 종료되면 사용하던 자원은 운영체제가 되찾아 간다. 그러나 프로세스의 종료 상태가 저장되는 프로세스 테이블의 해당 항목은 부모 프로세스가 wait() 시스템 콜을 호출할 때 까지 남아 있게 된다. 종료되었지만 부모 프로세스가 아직 wait() 시스템 콜을 호출 하지 않은 프로세스를 좀비 프로세스라고 한다. 일반적으로 프로세스가 종료되면 좀비 프로세스 상태가 아주 짧게 지속된다. 부모 프로세스가 wait() 시스템 콜을 호출하면 좀비 프로세스의 프로세스 식별자와 프로세스 테이블이 운영체제에 반환된다. 

만약 부모 프로세스가 wait() 시스템 콜을 호출하는 대신 종료한다면 무슨일이 벌어질까? 이러한 상황에 부딪힌 자식 프로세스를 고아 프로세스라고 부른다. 전통적인 UNIX는 고아 프로세스의 부모 프로세스를 init 프로세스로 재지정 함으로써 이 문제를 해결한다. init 프로세스는 주기적으로 wait() 시스템 콜을 호출하여 고아 프로세스의 종료 상태를 수집하고 프로세스 식별자와 프로세스 테이블을 반환한다.

대부분의 Linux 시스템은 init 프로세스를 systemd로 대체했지만, 후자 프로세스는 여전히 동일한 역활을 수행할 수 있지만 Linux는 systemd 이외의 프로세스가 고아 프로세스를 상속하고 종료 하도록 관리를 허용한다.