---
title: "CleanArchitecture - SOLID Principles"
date: 2020-03-13
last_modified_at: 2020-03-14
desc: "클린아키텍쳐 - SOLID 원칙"
keywords: "CleanArchitecture,SOLID"
permalink: "/cleanarchitecture/solid"
categories: 
    - CleanArchitecture
tags: 
    - CleanArchitecture
    - SOLID
---

# SOLID

[클린아키텍처](http://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)라는 블로그와 책을 읽고 여러 파트에 나뉘어 정리해볼려고 한다. 첫 파트는 SOLID 이다.

## 단일 책임 원칙(SRP, Single Responsibility Principle) 

한개의 모듈은 하나의 액터에 대해서만 책임 져야 한다.

> 여기서 _모듈_ 이란 단어의 가장 단순한 정의는 **소스 파일**을 의미한다.

### 예제

급여 앱의 Employee 클래는 SRP를 위반한다.

![imageSRP]({{ site.url }}{{ site.baseurl }}/assets/images/posts/image_SRP_01.png)

왜냐하면 위의 세 가지 메소드는 서로 매우 다른 세명의 액터를 책임지기 때문이다.

* caculatePay() 메소드는 회계팀에서 기능을 정의하며, CFO 보고를 위해 사용한다.
* reportHours() 메소드는 인사팀에서 기능을 정의하고 사용하며, COO 보고를 위해 사용한다.
* save() 메소드는 데이터베이스 관리자가 기능을 정의하고, CTO 보고를 위해 사용한다.

개발자가 세 메소드를 Employee라는 단일 클래스에 배치하여 세 액터가 서로 결합되어 버렸다. 이 결합으로 인해 CFO 팀에서 결정한 조치가 COO 팀이 의존하는 무언가에 영향을 줄 수 있다. 예를 들어 calculatePay() 메소드와 reportHours() 메소드가 초과 근무를 제외한 업무 시간을 계산하는 알고리즘을 공유한다고 해보자. 그리고 개발자는 코드 중복을 피하기 위해 이 알고리즘을 regularHours()라는 메소드에 넣었다고 해보자.

![imageSRP]({{ site.url }}{{ site.baseurl }}/assets/images/posts/image_SRP_02.png)

이제 CFO 팀에서 초과 근무를 제외한 업무 시간을 계산하는 방식을 약간 수정하기로 결정했다고 하자. 반면 인사를 담당하는 COO 팀에서 초과 근무를 제외한 업무 시간을 CFO 팀과는 다른 목적으로 사용하기 때문에, 이 같은 변경을 원하지 않는다고 해보자.

이 변경을 적용하는 업무를 할당받은 개발자는 calculatePay() 메소드가 regularHours()를 호출한다는 사실을 발견하지만, 이 함수가 reportHours() 메소드에서도 호출된다는 사실은 눈치채지 못한다. 개발자는 요청된 변경사항을 적용하고 신중하게 테스트한다. CFO 팀은 새로운 메소드가 원하는 방식으로 동작하는 검증하고, 시스템은 배포된다. 물론 COO 팀에서는 이러한 일이 벌어지고 있다는 사실은 인지하지 못한다. COO 팀 직원은 reportHours() 메소드가 생성한 보고서를 여전히 이용한다. 하지만 이제 이 보고서에 포함된 수치들은 엉터리다. 마침내 문제가 발견되고, COO는 격노한다. 잘못된 데이터로 인해 수백만 달러의 예산이 지출되었기 때문이다.

> 서로 다른 액터가 의존하는 코드를 너무 가까이 배치하면 위와 같은 문제가 발생한다. SRP는 서로 다른 액터가 의존하는 코드를 분리하라고 말한다.

### 결론 

단일 책임 원칙은 **메소드와 클래스 수준**의 원칙이다. 
> * 컴포넌트 수준에서는 공통 폐쇄 원칙이 된다. 
> * 아키텍처 수준에서는 아키텍처의 경계의 생성을 책임지는 변경의 축이 된다.

## 개방 폐쇄 원칙(OCP, Opne-Close Principle)

확장에는 열려있어야 하고, 변경에는 닫혀 있어야 한다.

### 예제

재무재표를 웹 페이지로 보여주는 시스템이 있다고 생각해보자. 웹 페이지에 표시되는 데이터는 스크롤할 수 있으며, 음수는 빨간색으로 출력한다. 

이제 이해관계자가 동일한 정보를 보고서 형태로 변환해서 흑백 프린터로 출력해 달라고 요청했다고 해보자. 이 보고서에는 페이지 번호가 제대로 매겨져 있어야 하고, 페이지마다 적절한 머리글과 바닥글이 있어야 하며, 표의 각 열에는 레이블이 있어야 한다고 해보자. 또한 음수는 괄호로 감싸야 한다. 당연히 새로운 코드를 작성해야 한다. 그렇다면 얼마나 많이 수정해야 할까?

이상적인 변경량은 _0_ 으로 보고, 소프트웨어 아키텍처가 훌륭하다면 변경되는 코드의 양이 가능한 한 최소화될 것이다.

어떻게 하면 될까? 서로 다른 목적으로 변경되는 요소를 적절하게 분리하고(단일 책임 원칙 SRP), 이들 요소 사이의 의존성을 체계화함으로써(의존성 역전 원칙 DIP) 변경량을 최소화할 수 있다.

단일 책임 원칙을 적용하면 데이터 흐름을 아래의 그림과 같은 형태로 만들 수 있다. 재무 데이터를 검사한 후 보고서용 데이터를 생성한 다음, 필요에 따라 두 가지 보고서 생성 절차 중 하나를 거쳐 적절히 포매팅 한다.

![imageOCP]({{ site.url }}{{ site.baseurl }}/assets/images/posts/image_OCP_01.png)

여기서 얻을 수 있는 가장 중요한건 생성이 두 개의 책임으로 분리된다는 사실이다. 하나는 보고서용 데이터를 계산하는 책임이며, 하나는 이 데이터를 웹으로 보여주거나, 종이로 프린트하기에 적합한 형태로 표현하는 책임이다.

이처럼 책임을 분리했다면, 두 책임 중 하나에서 변경이 발생하더라도 다른 하나는 변경되지 않도록 소스 코드 의존성도 확실히 조직화해야 한다. 또한, 새로 조직화한 구조에서는 행위가 확장될 때 변경이 발생하지 않음을 보장한다.

이러한 목적을 달성하려면 처리 과정을 클래스 단위로 분할하고, 이들 클래스를 아래 그림과 같이 컴포넌트 단위로 구분해야 한다. 이 그림에서 좌측 상단의 컴포넌트는 Controller 이고, 우측 상단은 Interactor 컴포넌트, 우측 하단은 Database 컴포넌트 이다. 좌측 하단에는 View와 Presenter를 담당하는 네 가지 컴포넌트가 위치한다.

![imageOCP]({{ site.url }}{{ site.baseurl }}/assets/images/posts/image_OCP_02.png)

> \<I> 로 표시된 클래스는 인터페이스이며, \<DS>로 표시된 클래스는 데이터 구조다. 화살표가 열려 있다면 사용 관계이며, 닫혀 있다면 구현관계 또는 상속관계다.

여기에서 주목할 점은 모든 의존성이 소스 코드 의존성을 나타낸다는 사실이다. 예를 들어 화살표가 A 클래스에서 B 클래스로 향한다면, A 클래스 에서는 B 클래스를 호출하지만 B 클래스에서는 A 클래스를 전혀 호출하지 않음을 뜻한다. 따라서 **FinancialDataMapper**는 구현 관계를 통해 **FinancialDataGateway**를 알지만, **FinancialDataGateway**는 **FinancialDataMapper**에 대해 알지 못한다.

여기서 또 주목해야할 점은 화살표가 오직 한 방향으로만 교차한다는 것이다. 이는 모든 컴포넌트 관계는 단방향으로만 이루어진다는 뜻이다. 이들 화살표는 변경으로부터 보호하려는 컴포넌트를 향하도록 그려진다.

다시 말하지만, A 컴포넌트에서 발생한 변경으로부터 B 컴포넌트를 보호하려면 반드시 A 컴포넌트가 B 컴포넌트에 의존해야 한다. 이 예제의 경우 Presenter에서 발생한 변경으로부터 Controller를 보호하고자 한다. 그리고 View에서 발생한 변경으로부터 Presenter를 보호하고자 한다. Interactor는 다른 모든 것에서 발생한 변경으로부터 보호하고자 한다. Interactor는 OCP를 가장 잘 준수할 수 있는 곳에 위치한다. Database, Controller, Presenter, View에서 발생한 어떤 변경도 Interactor에 영향을 주지 않는다.

> 왜 Interactor가 특별한 위치를 차지해야만 하는가?

> 답은 Interactor가 비즈니스 로직을 포함하기 때문이다. Interactor는 앱에서 가장 높은 수준의 정책을 포함한다. Interactor 이외의 컴포넌트는 모두 주변적인 문제를 처리한다. 가장 중요한 로직은 Interactor에서 담당한다. 마찬가지로 Presenter가 Controller보다는 부수적이더라도 View보다는 중심적인 문제를 처리한다.

보호의 계층구조가 수준(level)이라는 개념을 바탕으로 어떻게 생성되는지 주목하자. Interactor는 가장 높은 수준의 개념이며, 따라서 최고의 보호를 받는다. View는 가장 낮은 수준의 개념 중 하나이며, 따라서 거의 보호를 받지 못한다. Presenter는 View 보다는 높고 Controller나 Interactor보다는 낮은 수준에 위치한다.

이것이 바로 **아키텍처 수준**에서 OCP가 동작하는 방식이다. 아키텍트는 기능이 어떻게 왜 언제 발생하는지에 따라 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화한다. 컴포넌트 계층구조를 이와 같이 조직화하면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.

### 결론

OCP는 시스템 아키텍처를 떠받치는 원동력 중 하나다. OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 데 있다. 이러한 목표를 달성하려면 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야 한다.

## 리스코브 치환 원칙(LSP, Liskov's Substitution Principle)

S 타입의 객체에 각각 대응하는 T 타입을 이용해서 정의한 모든 프로그램 P 에서 T 타입의 자리에 S 타입으로 치환하더라도 P의 행위가 변하지 않는다면, S는 T의 하위 타입이다.

### 예제

LSP를 위반하는 전형적인 문제로는 정사각형/직사각형 문제가 있다. 

![imageLSP]({{ site.url }}{{ site.baseurl }}/assets/images/posts/image_LSP_01.png)

이 예제에서 Square는 Rectangle의 하위 타입으로는 적합하지 않다. Rectangle의 높이와 너비는 서로 독립적으로 변경될 수 있는 반면, Square의 높이와 너비는 반드시 함께 변경되어야 하기 떄문이다. 

User는 상호작용하고 있는 대상이 Rectangle이라고 생각하므로 혼동이 생길 수 있다. 아래의 코드를 보면 혼동의 이유가 분명해진다.

```kotlin
val r: Rectangle = ...
r.setW(5)
r.setH(2)
assert(r.area() == 10)
```

... 코드에서 Square를 생성한다면 assert 문은 실패하게 된다.

이런 형태의 LSP 위반을 막기 위한 유일한 방법은 Rectangle이 실제로 Square인지를 검사하는 메커니즘을 User에 추가하는 것이다. 하지만 이렇게 되면 User의 행위가 사용하는 타입에 의존하게 되므로 결국 타입을 서로 치환할 수 없게 된다.

### LSP와 아키텍처

객체 지향 초창기에는 LSP는 상속을 사용 하도록 가이드하는 방법 정도로 간주되었다. 하지만 시간이 지나면서 LSP는 인터페이스와 구현체에도 적용되는 더 광범위한 소프트웨어 설계 원칙으로 변모해 왔다.

생각보다 많은 상황에서 LSP를 적용할 수 있다. 잘 정의된 인터페이스와 그 인터페이스의 구현체끼리의 상호 치환 가능성에 기대는 사용자들이 존재하기 때문이다. 아키텍처 관점에서 LSP를 이해하는 최선의 방법은 이 원칙을 어겼을 때 시스템 아키텍처에서 무슨 일이 일어나는지 관찰하는 것이다.

### 결론

LSP는 **아키텍처 수준**까지 확장할 수 있다. 치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야 할 수 있기 떄문이다.

## 인터페이스 분리 원칙(ISP, Interface Segregation Principle)

인터페이스를 분리하여 사용하지 않는 기능은 배제하며, 필요한 기능에만 의존해야 한다.

### 예제

일반적으로 필요 이상으로 많은 기능을 포함하는 모듈에 의존하는 것은 해로운 일이다. 소스 코드 의존성의 경우 이는 분명한 사실인데, 불필요한 재컴파일과 재배포를 강제하기 때문이다. 하지만 더 고수준인 아키텍처 수준에서도 마찬가지 상황이 발생한다.

예를 들어 S 시스템 구축에 참여하고 있는 아키텍트가 있다고 해보자. 아키텍트는 F라는 프레임워크를 시스템에 도입하기를 원한다. 그리고 F 프레임워크 개발자는 특정한 D 데이터베이스를 반드시 사용하도록 만들었다고 가정해보자. 따라서 S는 F에 의존하며, F는 다시 D에 의존하게 된다.

![imageISP]({{ site.url }}{{ site.baseurl }}/assets/images/posts/image_ISP_01.png)

F에서는 불필요한 기능, 따라서 S와는 전혀 관계없는 기능이 D에 포함된다고 가정하자. 그 기능이 D 내부에서 변경이 발생하면, F를 재배포해야 할 수도 있고, 따라서 S까지 재배포해야 할지 모른다. 더 심각한 문제는 D 내부의 기능 중 F와 S에서 불필요한 그 기능에 문제가 발생해도 F와 S에 영향을 준다는 사실이다.

### 결론

불필요한 기능을 가진 무언가에 의존하면 예상치도 못한 문제에 빠진다.

## 의존성 역전 원칙(DIP, Dependency Inversion Principle)

추상에 의존하며 구체에는 의존하지 않아야 한다.

### DIP 실천법 4가지

1. 변동성이 큰 구체 클래스를 참조하지 말라.
2. 변동성이 큰 구체 클래스로부터 파생하지 말라.
3. 구체 함수를 오버라이드 하지 말라.
4. 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.

### 예제

위의 4가지 규칙들을 준수하려면 변동성이 큰 구체적인 객체는 특별히 주의해서 생성해야 한다. 이러한 점은 조심하는게 당연한데, 사실상 모든 언어에서 객체를 생성하려면 해당 객체를 구체적으로 정의한 코드에 대해 소스 코드 의존성이 발생한다.

자바 등 대다수의 객체지향 언어에서 이처럼 바람직하지 못한 의존성을 처리할 때 추상 팩토리 패턴을 사용하곤 한다.

![imageDIP]({{ site.url }}{{ site.baseurl }}/assets/images/posts/image_DIP_01.png)

위의 그림에서 추상 팩토리 패턴을 사용한 구조를 볼 수 있다. Application은 Service 인터페이스를 통해 Concrete Impl을 사용하지만, Application에서는 어떤 식으로든 ConcreteImpl의 인스턴스를 생성해야 한다. Concrete Impl에 대해 소스 코드 의존성을 만들지 않으면서 이 목적을 이루기 위해 Application은 Service Factory 인터페이스의 makSvc 메소드를 호출한다. 이 메소드는 Service Factory로부터 파생된 Service Factory Impl에서 구현된다. 그리고 Service Factory Impl 구현체가 Concrete Impl의 인스턴스를 생성한 후 Service 타입으로 반환한다.

위의 그림에서 곡선은 아키텍처 경계를 뜻한다. 이 곡선은 구체적인 것들로부터 추상적인 것들을 분리한다. 소스 코드 의존성은 해당 곡선과 교차할 때 모두 한 방향, 즉 추상적인 쪽으로 향한다.

곡선은 시스템을 두 가지 컴포넌트로 분리한다. 하나는 추상 컴포넌트이며, 다른 하나는 구체 컴포넌트다. 추상 컴포넌트는 앱의 모든 고수준 비즈니스 로직을 포함한다. 구체 컴포넌트는 비즈니스 로직을 다루기 위해 필요한 모든 세부사항을 포함한다. 

제어흐름은 소스 코드 의존성과는 정반대 방향으로ㅗ 곡선을 가로지른다는 점에 주목하자. 다시 말해 소스 코드 의존성은 제어흐름과는 반대 방향으로 역전된다. 이러한 이유로 이 원칙을 의존성 역전이라고 부른다.

### 구체 컴포넌트

위의 그림에서 구체 컴포넌트에는 구체적인 의존성이 하나 있고, 따라서 DIP에 위배된다. 이는 일반적인 일이다. DIP 위배를 모두 없앨 수는 없다. 하지만 DIP를 위배하는 클래스들은 적은 수의 구체 컴포넌트 내부로 모을 수 있고, 이를 통해 시스템의 나머지 부분과는 분리할 수 있다.

대다수의 시스템은 이러한 구체 컴포넌트를 최소한 하나 이상 포함할 것이다. 흔히 이 컴포넌트를 메인이라고 부르는데, main 함수를 포함하기 때문이다. 위의 그림의 경우 main 함수는 Service Factory Impl의 인스턴스를 생성한 후, 이 인스턴스를 Service Factory 타입으로 전역 변수에 저장할 것이다. 그런 다음 Application은 이 전역 변수를 이용해서 Service Factory Impl의 인스턴스에 접근할 것이다.

### 결론

DIP는 아키텍처 다이어그램에서 가장 눈에 드러나는 원칙이 될 것이다. 위의 그림에서 곡선은 아키텍처 경계가 될 것이다. 그리고 의존성은 이 곡선을 경계로, 더 추상적인 엔티티가 있는 쪽으로만 향한다. 추후 이 규칙은 의존성 규칙이라 부를 것이다.

# 요약

## 단일 책임 원칙(SRP, Single Responsibility Principle)  

* 한개의 모듈은 하나의 액터에 대해서만 책임 져야 한다.
* SRP는 클래스와 메소드 수준의 원칙이다.

## 개방 폐쇄 원칙(OCP, Opne-Close Principle)

* 확장에는 열려있어야 하고, 변경에는 닫혀 있어야 한다.
* 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야한다.
* 컴포넌트를 보호하려면 변경이 발생하는 컴포넌트가 보호하려는 컴포넌트에 의존해야 한다.
* OCP는 아키텍처 수준의 원칙이다.

## 리스코브 치환 원칙(LSP, Liskov's Substitution Principle)

* S 타입 객체 각각에 대응하는 T 타입 객체가 있고, T 타입을 이용해서 정의한 모든 프로그램 P에서 T 타입의 자리에 S 타입을 치환해도 P의 행위가 변하지 않는다면 S는 T의 하위 타입이다.
* LSP를 어겼을 때 특정 타입에 대한 의존이 강제 되고, 추가 검증 코드가 추가 된다.
* LSP는 아키텍처 수준까지 반드시 확장 해야 한다.

## 인터페이스 분리 원칙(ISP, Interface Segregation Principle)

* 인터페이스를 분리하여 사용하지 않는 기능을 배제하며, 필요한 기능에만 의존한다.
* 불필요한 기능을 가진 메소드들이 서로 공유되었을 때 예상치 못한 문제가 발생할 수 있다.
* 불필요한 기능을 최대한 배제하여 서로의 영향이 없도록 유지해야 한다.

## 의존성 역전 원칙(DIP, Dependency Inversion Principle)

* 추상에 의존하며 구체에는 의존하지 않아야 한다.
* 4가지 실천법으로 변동성이 큰 구현체에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하자.
* 모든 DIP 위배를 없앨 수는 없다. 하지만 DIP를 위배하는 클래스들은 적은 수의 구체 컴포넌트 내부로 모을 수 있다. 즉 시스템의 나머지 부분과 분리할 수 있다. 

## 참조

[클린아키텍처 책](http://www.yes24.com/Product/Goods/77283734)