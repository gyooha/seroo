---
title: "Recusive Data Structure"
date: 2020-08-27
last_modified_at: 2020-08-27
desc: "함수형 프로그래밍 - 재귀적 자료구조"
keywords: "Functional Programming, Recursive Data Structure"
permalink: "/fp/type_component"
categories: 
    - Functioanl Programming
tags: 
    - FP
    - Functioanl Programming
    - Recursive Data Structure
---

# 재귀

함수형 프로그래밍에서 명령문을 반복할 때 루프 대신 재귀를 사용한다. 

## 함수형 프로그래밍에서 재귀가 가지는 의미

**재귀는 어떤 함수의 구현 내부에서 자기 자신을 호출하는 함수를 정의하는 방법을 의미한다.** 특히 수학에서 재귀는 빈번하게 사용되는 개념이다. 예를 들어 수학에서 피보나치 수열의 경우 점화식으로 F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2)로 정의된다. F(0)과 F(1)은 첫 번째 값과 두 번째 값을 의미하고 상수로 정의하였다. F(n)은 F(n-1)과 F(n-2)를 호출한 결과를 더한 결과다. 즉 이전 값 두 개의 합을 의미한다. F(n)의 내부에서 자기 자신인 F(n-1), F(n-2)를 호출했기 때문이 이 점화식은 재귀이다.

### 피보나치 수열을 명령형 프로그래밍으로 구현한 예제

명령형 프로그래밍에서는 값을 변경할 수 있기 때문에 재귀를 사용하지 않아도 피보나치 수열 문제를 풀 수 있다. 복잡한 프로그래밍을 명령형 방식으로 풀기 위해서는 간단한 문제로 나누어 접근하는 방식이 좋은데, 이러한 접근 방법을 **동적 계획법이라고 한다.** 아래 예제에서는 동적 계획법을 이용하여 피보나치 수열을 구현하였다.

```kotlin

fun main() {
    println(fiboDynamic(10, IntArray(100)))
}

private fun fiboDynamic(n: Int, fibo: IntArray): Int {
    fibo[0] = 0
    fibo[1] = 1

    for (i in 2..n) {
        fibo[i] = fibo[i - 1] + fibo[i - 2]
    }

    return fibo[n]
}

```

fiboDynamic 함수는 피보나치 수열의 결괏값을 한번에 얻으려고 하지 않고 단계별 결괏값을 구해서 합하였다. 이 과정에서 피보나치 수열의 이전 값들을 기억하기 위한 메모리 IntArray(100)을 확보해 놓았다. 루프가 반복되면서 이전 값이 필요하면 메모리에 저장된 값을 사용한다.

위의 예제를 보면 루프 내에서 fibo 배열에 값을 할당하는 걸 볼 수 있는데, 순수한 함수형 프로그래밍에서는 이러한 값 할당 자체가 불가능하다. 미리 할당된 배열의 크기는 100으로 고정되어 있는데, 명령형 프로그래밍에서는 무한대를 자료구조에 담을 수 없기 때문이다. 따라서 본 예제에서는 피보나치 수열을 100개까지만 계산할 수 있다.

### 피보나치 수열을 재귀로 구현한 예제

이번에는 피보나치 수열을 재귀로 풀어보자.

```kotlin

fun main() {
    println(fiboRecursion(10))
}

private fun fiboRecursion(n: Int): Int = when (n) {
    0 -> 0
    1 -> 1
    else -> fiboRecursion(n - 1) + fiboRecursion(n - 2)
}

```

fiboRecursion 함수에서는 내부에서 자기 자신을 호출하여 재귀로 피보나치 수열 문제를 해결하였다. 재귀로 구현한 예제에는 고정 메모리 할당이나 값의 변경이 없다. 메모리를 직접 할당해서 사용하지 않고, 스택을 활용한다. 재귀 호출을 사용하면 컴파일러 내부적으로 현재 호출하는 함수에 대한 정보들을 스택에 기록해 두고 다음 함수를 호출한다. 프로그래머가 직접 메모리를 할당하지 않아도 컴파일러에 의해서 관리된다.

여기서 피보나치 수열의 크기에 제한을 두지 않았다. 이러한 경우 큰 수를 호출하면 스택 오버플로우가 발생한다. 아래에서 이러한 문제점의 원인을 분석하고 해결해보자.

### 함수형 프로그래밍에서 재귀

함수형 프로그래밍에서는 어떻게(how) 값을 계산할 수 있을지 선언하는 대신 **무엇(what)을 선언할지를 고민**해야 한다. for나 while문과 같은 반복 명령어는 구조적으로 어떻게 동작해야 하는지를 명령하는 구문이다. 따라서 함수형 프로그래밍에서는 루프를 사용하여 해결하던 문제들을 재귀로 풀어야 한다.

순수한 함수형 언어 하스켈은 반복 명령어를 아예 제공하지 않는다. 하지만 코틀린은 멀티 패러다임 언어이기 때문에 반복 명령어를 지원한다. 모든 반복문은 재귀로 구현할 수 있다. 재귀는 반복문에 비하여 복잡한 알고리즘을 간결하게 표현할 수 있지만, 다음과 같은 문제점을 가진다.

* 동적 계획법 방식에 비해서 성능이 느리다.
* 스택 오버플로우 오류가 발생할 수 있다.

> 함수형 프로그래밍에 익숙해지기 위해서 반복문 대신 재귀를 사용할 것을 권장한다.

## 메모이제이션으로 성능 개선하기

**메모이제이션이란, 어떤 반복된 연산을 수행할 때 이전에 계산했던 값을 캐싱해서 중복된 연산을 제거하는 방법이다.** 연산 횟수가 줄어 속도가 개선되므로 동적 계획법의 핵심이 되는 기술이기도 하다.

### 재귀적인 방식의 피보나치 수열 예제

앞의 피보나치 수열의 예를 다시 한번 살펴보자. 결과를 확인하기 위해 fiboRecursion 함수에 로그를 추가했다.

```kotlin

fun main() {
    println(fiboRecursion(10))
}

private fun fiboRecursion(n: Int): Int {
    println("fiboRecursion($n)")
    
    return when (n) {
        0 -> 0
        1 -> 1
        else -> fiboRecursion(n - 1) + fiboRecursion(n - 2)
    }
}

```

fiboRecursion(6)을 실행해보면 아래와 같다.

```
fiboRecursion(6)
fiboRecursion(4)
fiboRecursion(2)
fiboRecursion(0)
fiboRecursion(1)
fiboRecursion(3)
fiboRecursion(1)
fiboRecursion(2)
fiboRecursion(0)
fiboRecursion(1)
fiboRecursion(5)
fiboRecursion(3)
fiboRecursion(1)
fiboRecursion(2)
fiboRecursion(0)
...
```

총 24번 호출되었다. 더 큰 값을 테스트할수록 로그는 기하급수적으로 늘어난다. 함수 내부에서 자기 자신을 두 번 호출하기 때문에 단계가 지날 때마다 호출 개수는 두 배씩 늘어난다. 따라서 n이 N일 때 시간 복잡도는 O(2n제곱)이 된다. 그리고 이전에 했던 연산 결과를 저장해 두지 않았기 때문에 같은 연산을 여러 번 호출한다. 상당히 비효율적인 걸 알 수 있다.

### 메모이제이션을 사용한 피보나치 수열 예제

메모이제이션을 이용하면 불필요한 재귀 호출을 줄이고, 성능을 개선할 수 있다. 위의 코드예제를 메모이제이션을 이용하여 재작성 해보자.

```kotlin
var memo = Array(100, { -1 })

fun fiboMemoization(n: Int) = when {
    n == 0 -> 0
    n == 1 -> 1
    memo[n] != -1 -> memo[n]
    else -> {
        println("fiboMemoization($n)")
        memo[n] = fiboMemoization(n - 2) + fiboMemoization(n - 1)
        memo[n]
    }
}
```

배열 memo를 연산의 결괏값이 될 수 없는 -1로 초기화해 놓고, 중간 연산 결과를 저장하여 사용했다. 중간 결과의 값이 -1이 아니라면 이미 연산된 것이므로 종료조건을 추가했다. fiboMemoization(6)을 실행하면 다음과 같이 출력된다.

```
fiboMemoization(6)
fiboMemoization(4)
fiboMemoization(2)
fiboMemoization(3)
fiboMemoization(5)
```

fiboMemoization은 총 5번 호출되었다. 시간 복잡도는 O(N)으로 개선된다. 동일한 값으로 두 번 재귀 호출하지 않는다. 이와 같이 메모이제이션을 사용하면 비효율적인 호출을 제거해서 성능을 개선할 수 있다.

### 재귀의 문제점을 함수적으로 해결하기

메모이제이션을 이용해 재귀의 효율성을 높이기는 했는데, 이 방법이 함수적인 해볍인지는 살펴봐야 한다. 순수한 함수의 요건을 다시 따져보자.

순수한 함수는 부수효과가 없어야 한다. 그러나 예제에서는 memo라는 전역변수를 선언함으로써 부수효과가 발생했다. 또한 순수한 함수는 불변성을 띤다. 그러나 memo를 생성하고 재귀 함수 내에서 값을 수정하였으므로 불변성을 지키지 못하였다. 따라서 이 해법은 함수적이지 않다.

그렇다면 함수형 프로그래밍에서는 어떻게 메모이제이션으로 재귀의 성능을 개선할 수 있을까? 부수효과를 없애기 위해 이미 계산된 값을 별도의 메모리에 저장하지 않고, 재귀 함수의 매개변수로 받아서 캐싱을 대신하면 된다.

```kotlin
fun main() {
    println(fiboFP(6)) // 8 출력
}

fun fiboFP(n: Int): Int = fiboFP(n, 0, 1)

tailrec fun fiboFP(n: Int, first: Int, second: Int): Int = when (n) {
    0 -> first
    1 -> second
    else -> fiboFP(n - 1, second, first + second)
}
```

첫 번째 fiboFP 함수는 재귀 함수의 입력을 제한하기 위한 함수로 내부에서 실제로 재귀 호출을 수행하는 함수를 호출한다. 두 번째 fiboFP 함수는 재귀 호출을 수행하는 함수로 이전에 계산된 값을 매개변수로 받는다. 입력 n은 피보나치 수열의 크기를 의미하며 하나씩 감소되어 1이 되면 second를 반환하고 종료한다. first는 현재 피보나치 수열의 바로 이전 값이고, second는 현재 피보나치 수열의 두 단계 이전 값이다.

## 꼬리 재귀로 최적화 하기

tailrec은 언어 차원에서 제공하는 어노테이션이다. 만약 tailrec이 명시된 함수가 꼬리 재귀의 조건에 부합하지 않으면, IDE에서는 경고 메시지를 주고, 컴파일러 최적화가 발생하지 않는다. 그렇다면 꼬리 재귀란 무엇이고, 최적화는 어떻게 하는지 알아보자.

### 꼬리재귀 최적화란?

**꼬리 재귀란 어떤 함수가 직간접적으로 자기 자신을 호출하면서도 그 호출이 마지막 연산인 경우를 말한다.** 그리고 이 마지막 연산인 호출을 꼬리 호출이라 한다. 여기서 주의할 점은 마지막 호출에서 재귀 함수만 호출되어야 한다는 것이다. 일반적인 재귀는 호출이 반복되므로 깊이가 깊어지면 스택 오버플로가 발생할 수 있다. 그러나 꼬리 호출일 때는 스택 오버플로 문제를 일으키는 스택 프레임을 컴파일러가 재사용할 수 있다.
재귀가 꼬리 호출인 경우, 재귀의 마지막 결과가 재귀 호출 전체의 결과와 일치한다. 따라서 컴파일러는 새로운 스택 프레임을 생성해서 재귀 호출하지 않고, 현재 스택 프레임에서 함수의 시작 지점으로 점프하여 재귀 호출을 할 수 있다. 이 경우 재귀를 사용했지만, 반복문을 사용한 것처럼 최적화할 수 있다. 
이렇게 꼬리 재귀 조건에 부합하는 코드라는 것을 컴파일러가 인지하여 최적화 하는 것을 꼬리 재귀 최적화라 한다. 꼬리 재귀 최적화가 일어나면 메모이제이션과 같은 방법을 사용하지 않고도 성능을 향상시키고 스택 오버플로를 방지할 수 있다.

## 상호 재귀를 꼬리 재귀로 최적화하기

### 상호 재귀

상호 재귀(mutual recursion)는 함수 A가 함수 B를 호출하고, 함수 B가 다시 함수 A를 호출하는 것을 말한다. 상호 재귀의 예로 홀수, 짝수를 판단하는 예를 보자

```kotlin
fun main() {
    println(even(9999)) // false 출력
    println(odd(9999)) // true 출력
    println(even(999999)) // stackoverflow 발생
}

fun even(n: Int) = when (n) {
    0 -> true
    else -> odd(n - 1)
}

fun odd(n: Int) = when (n) {
    0 -> false
    else -> even(n - 1)
}
```

even 함수는 odd 함수를 호출하고, odd 함수가 다시 even 함수를 호출함으로써 반복적으로 상호 재귀 호출을 하고 있다. 두 함수의 종료조건 중, 한 가지에 만족하면 재귀 호출은 종료되고 원하는 결과를 얻을 수 있다.

even(999999)는 매개변수의 값이 매우 높아, 스택 오버플로가 발생한 것이다. 함수형 언어의 컴파일러도 일반적으로 상호 재귀를 최적화할 수는 없다. 스택 오버플로가 발생하지 않게 하려면 상호 꼬리 재귀로 변경해야 한다.

### 트램펄린

**상호 꼬리 재귀를 가능하게 하려면 트램펄린을 사용하면 된다.** 트램펄린은 반복적으로 함수를 실행하는 루프다. 이때 실행되는 함수를 성크라고 하는데, 성크는 다음에 실행될 함수를 매번 새로 생성하여 반환한다. 트램펄린에서 성크는 한 번에 하나만 실행된다. 프로그램을 충분히 작은 성크로 쪼갠 후 트램펄린에서 점프하듯이 반복 실행하면 스택이 커지는 것을 막을 수 있다.

```kotlin
sealed class Bounce<A>
data class Done<A>(val result: A): Bounce<A>()
data class More<A>(val thunk: () -> Bounce<A>): Bounce<A>()

tailrec fun <A> trampoline(bounce: Bounce<A>): A = when (result) {
    is Done -> bounce.result
    is More -> trampoline(bounce.thunk())
}
```

Bounce라는 클래스를 정의하고, Bounce 클래스를 확장한 Done과 More 클래스를 정의했다. 트램펄린이 끝나면 Bounce는 Done이 되고, 더 호출할 게 남아 있다면 More가 된다. Done은 최종적으로 반환할 결과인 result를 매개변수로 받고, More는 다음에 실행할 함수 thunk를 매개변수로 받는다. 언어마다 표현은 다르지만 트램펄린은 종료조건을 의미하는 Done과 다음 트램펄린에 성크를 넘기기 위한 More가 포함 되어야 한다. 
trampoline 함수는 Bounce를 매개변수로 받아서 Done이면 결과를 반환하고 종료하고, More면 다음에 실행할 함수를 매개변수로 trampoline 함수를 재귀 호출한다. 이때 **값을 넘기는 것이 아니라 함수를 넘긴다는 것**에 유의하자. 값이 아니라 함수를 넘기기 때문에 재귀 호출하는 시점이 아니라 실제로 값이 사용되는 시점에 값을 평가하게 된다.
trampoline 함수를 보면 tailrec으로 선언되어 있다. 따라서 trampoline 함수는 코틀린 컴파일러에 의해 최적화된다. 이제 trampoline 함수를 활용해서 홀수 짝수 함수를 다시 작성하자.

```kotlin
fun main() {
    println(trampoline(even(999999)))
    println(trampoline(odd(999999)))
}

fun odd(n: Int): Bounce<Boolean> = when (n) {
    0 -> Done(false)
    else -> More { even(n - 1) }
}

fun even(n: Int): Bounce<Boolean> = when (n) {
    0 -> Done(true)
    else -> More { odd(n - 1) }
}
```

odd와 even 함수의 최종 반환 타입은 Boolean이고, trampoline 함수에 매개변수로 넘겨야 하므로 반환 타입은 Bounce<Boolean>이다. 함수의 구현부에서는 종료조건에는 최종 결과를 포함한 Done을 반환하고, 종료조건에 부합하지 않으면 다음에 실행할 함수를 포함한 More를 바노한한다. 이때 이 함수는 객체 내부의 상태값을 매개변수로 할 수 있다. 이렇게 작성된 프로그램은 트램펄린에서 점프하듯이 함수를 반복 호출한다.

## 정리

* 함수형 프로그래밍에서 명령문을 반복할 때 루프 대신 재귀를 사용
* 일반 재귀는 스택에 안전하지 않고, 메모이제이션 방식은 불변성을 깨뜨린다.
* 꼬리 재귀란 어떤 함수가 직간접적으로 자기 자신을 호출하면서도 그 호출이 마지막 연산인 경우를 말한다.
* 꼬리 재귀 조건에 부합하는 코드라는 것을 컴파일러가 인지하여 최적화 하는 것을 꼬리 재귀 최적화 라고 한다.