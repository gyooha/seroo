---
title: "Android Process and thread"
date: 2020-02-27
last_modified_at: 2020-03-01
desc: "안드로이드 프로세스와 스레드"
keywords: "Android,Process,Thread"
permalink: "/android/process-and-thread"
categories: 
    - Android
tags: 
    - Android
    - Process
    - Thread
---

# Processes and threads

한 앱(Application)의 컴포넌트(Component)가 실행되고 있지 않은 상황에서 앱이 실행될 때 안드로이드 시스템은 단일 스레드로 새로운 Linux 프로세스를 시작한다. 기본적으로 같은 앱의 컴포넌트는 같은 프로세스와 스레드(Main Thread)에서 시작된다. 하지만 앱과 컴포넌트를 위한 프로세스가 이미 있다면 컴포넌트는 이미 존재하는 프로세스와 스레드에서 실행된다. 그러나 한 앱에서 각각의 컴포넌트를 다른 프로세스에서 실행할 수 있게 설정할 수 있으며, 모든 프로세스에서 추가적인 스레드를 만들 수 있다.

## Processes

일반적으로 모든 컴포넌트는 같은 앱, 같은 프로세스에서 실행되며 변경하는 것을 권장하지 않는다. 그러나 프로세스 제어가 필요한 상황이 있을 경우 **Manifest**파일에서 제어할 수 있다.

**Manifest**에는 **Activity**, **Service**, **Receiver**, **Provider**같은 각각의 컴포넌트에 대한 요소의 정보가 적혀있고, Manifest에는 해당 컴포넌트가 실행되는 프로세스를 지정할 수 있는 _android:process_ 속성을 지원한다. 

> _android:process_ 속성을 이용해 설정하면 컴포넌트를 아래와 같이 작동하도록 변경할 수 있다.
> * 각 컴포넌트가 자체 프로세스에서 실행되도록 할 수 있다.  
> * 일부 컴포넌트가 프로세스를 공유하고 다른 컴포넌트는 공유하지 않도록 할 수 있다.

_android:process_ 설정을 통해서 같은 Linux 사용자 아이디와 같은 인증서로 서명되도록 할 수 있고, 다른 앱의 컴포넌트를 동일한 프로세스에서 실행할 수 있다.

> **Manifest**의 _application_ 요소에도 _android:process_ 속성을 지원한다. _android:process_ 속성이 설정되면 **모든 컴포넌트**에 속성이 적용된다.

안드로이드 시스템이 메모리가 부족하거나 사용자에게 즉시 서비스를 제공하기 위해 프로세스에 필요한 경우, **프로세스 종료 우선순위**에 의해 **프로세스가 종료될 수 있다**. 종료된 프로세스에 따라서 프로세스 안의 실행중인 앱은 강제종료 된다. 하지만 컴포넌트가 다시 수행되면 해당 컴포넌트에 대한 프로세스가 다시 시작된다.

> 프로세스 종료 우선순위는 [_여기_](https://developer.android.com/guide/components/activities/process-lifecycle)를 참고하자.

## Threads

앱이 실행될 때 실행된 앱을 위해 안드로이드 시스템에서 하나의 스레드를 만들어 주는데 이것을 _메인 스레드_ 라고 한다. 

> 안드로이드 시스템에서 <em>메인 스레드</em>는 굉장히 중요하다. 왜 중요한지는 아래와 같다.
> * UI 그리기를 포함하여 적절한 사용자 UI에 이벤트를 전달한다.
> * 앱에서 거의 모든 안드로이드 UI 툴킷 컴포넌트와 상호작용에 사용하는 스레드이다.

<em>메인 스레드</em>는 종종 _UI 스레드_ 라고 불린다. 특정 상황에서 메인 스레드가 UI 스레드가 아닐 수 있다. 

> **다른 스레드상에서 복수의 뷰를 가지고 있는 시스템 앱**의 경우 UI 스레드와 메인 스레드가 다를 수 있다. 그래서 @UIThread 어노테이션은 앱의 뷰 계층에서만 사용해야 하고, @MainThread 어노테이션은 앱의 라이프사이클 관련 코드에서 사용해야 한다.

안드로이드 시스템은 각각의 인스턴스를 위해 스레드를 분리하지 않는다. 모든 컴포넌트는 같은 프로세스의 UI 스레드 안에서 초기화가 진행되고, UI 스레드에서 각각의 컴포넌트는 시스템의 호출을 전달받는다. 따라서 시스템 콜백 메소드는 항상 앱 프로세스의 UI 스레드에서 결과를 받는다.

예를 들어, 한 화면에서 사용자가 버튼을 터치하면 터치 UI 스레드는 터치 이벤트를 해당 위젯(이 예제에서는 버튼)에 전달한다. 그리고 버튼이 눌린 상태에서 다시 눌리기 전 상태로 복귀하기 위해 이벤트 큐에 무효화 요청을 보내고, UI 스레드는 해당 요청을 이벤트 큐에서 꺼내어 위젯에 다시 그리라고 통보한다.

사용자 상호작용에 응답하여 앱이 집중적인 작업을 수행할 때, 단일 스레드 모델은 앱을 제대로 구현하지 않으면 성능이 저하될 수 있다. 정확히 말하자면, 네트워크 작업이나 데이터베이스 작업을 UI 스레드에서 진행하는 경우 작업이 실행되는 동안 UI 스레드가 차단된다. 

UI 스레드가 차단되면, 그리기 이벤트 같은 이벤트들을 보낼 수 없고, 사용자 관점에서는 앱이 멈춰있는 것으로 보인다. 더 나쁜것은 UI 스레드가 몇 초 이상 차단되면 ANR 다이얼로그가 사용자에게 보여지고, 사용자는 앱을 강제종료 할 수 있으며, 이 행위는 앱의 삭제까지 이어질 수 있다.

> 추가적으로 안드로이드 UI 툴킷은 스레드에 안전하지 않다. 그래서 개발자는 UI를 UI 스레드 외의 스레드에서 조작하면 안된다. 이 말은 즉 UI 조작은 반드시 UI 스레드에서 이루어져야 하며, 안드로이드 단일 스레드 모델의 룰은 아래와 같다.
> * UI 스레드를 블록하면 안된다.
> * UI 스레드외의 스레드에서 안드로이드 UI 툴킷에 접근하면 안된다.

## Worker Thread

Thread 섹션에서 설명했듯이 UI 스레드를 차단하지 않는것이 매우 중요하다. 네트워크 작업, 데이터베이스 작업같이 긴 수행시간을 가진 작업을 수행할 경우 Background, Worker 스레드로 분리해서 작업해야 한다.

> Background, Worker 스레드에서 UI에 접근하면 안된다!!!

안드로이드에서 외부 스레드(Background, Worker)에서 UI 스레드로 접근하는 몇가지 방법을 제공한다.

1. Activity.runOnUiThread(Runnable)
2. View.post(Runnable)
3. View.postDelayed(Runnable, long)

```kotlin
fun onClick(v: View) {
    Thread(Runnable {
        // a potentially time consuming task
        val bitmap = processBitMap("image.png")
        imageView.post {
            imageView.setImageBitmap(bitmap)
        }
    }).start()
}

위의 예제의 경우 외부 스레드에서 백그라운드 작업을 마친 후 ImageView 조작은 항상 UI 스레드에서 이루어 진다.
```

## Thread safe method

특정 상황에서 하나의 스레드 이상에서 호출되는 메소드의 경우 스레드에 안전하도록 작성해야 한다.

이 상황은 주로 바운드 서비스안에 있는 메소드 같이 메소드를 외부에서 호출하는 경우에 발생한다. _IBinder_ 에서 구현된 메소드에 대한 호출이 <em>IBinder</em>가 실행되고 있는 것과 동일한 프로세스에서 실행중인 경우 호출자 스레드에서 메소드가 실행된다. 그러나 _IBInder_ 에서 구현된 메소드가 다른 프로세스에서 호출될 때 해당 메소드는 IBinder와 동일한 프로세스에서 시스템이 유지하고 있는 스레드 풀에서 선택한 스레드로 실행된다.(이 경우 프로세스의 UI 스레드에서는 실행되지 않는다.) 

예를들어 서비스 프로세스의 UI 스레드에서 서비스의 _onBind()_ 메소드를 호출하지만, <em>onBind()</em>가 반환하는 객체는 스레드 풀 안의 다른 스레드로부터 호출된다. 

> 서비스는 한 개 이상의 클라이언트를 가질 수 있고, 한 개 이상의 스레드 풀 안의 스레드가 **동시에** **동일한** _IBinder_ 메소드를 사용할 수 있다.

마찬가지로 <em>컨텐트프로바이더</em>는 다른 프로세스에서 발생하는 데이터 요청을 받을 수 있다. _컨텐트리졸버_ 및 _컨텐트프로바이더_ 클래스는 프로세스 간 IPC 관리 방법에 관한 자세한 사항은 숨기지만, **이러한 요청**에 응답하는 _컨텐트프로바이더_ 메소드는 프로세스에 대한 UI 스레드가 아니라, _컨텐트프로바이더_ 프로세스안의 스레드 풀에서 호출된다.

> 이러한 요청 이란?
> 컨턴트프로바이드 메소드 - _query()_, _insert()_, _delete()_, _update()_, _getType()_ 를 의미한다.

## Interprocess communication

안드로이드는 RPC(remote procedure) 호출을 이용한 IPC(interprocess communication) 메커니즘을 제공하는데, 이 메커니즘은 특정 메소드가 Activity나 다른 앱의 컴포넌트에 의해 호출되지만 원격으로 실행되고, 결과도 호출자에게 전달된다.

여기에는 메소드 호출과 그 데이터를 운영체제가 이해할 수 있는 수준으로 분해하여 로컬 프로세스 주소 공간에서 원격 프로세스 주소 공간으로 전송한 다음, 거기서 메소드 호출을 재조립하고 다시 재연하는 작업을 진행한다.

그런 다음 반환 값은 반대 방향으로 전송된다. Android는 이러한 IPC 트랜잭션을 수행하기 위한 모든 코드를 제공하므로 RPC 프로그래밍 인터페이스를 정의하고 구현하는 데 집중할 수 있다.

## 요약

* (기존에 프로세스가 존재하지 않는다는 전제하에)앱이 실행될 때 메인스레드로 Linux 프로세스를 시작한다.
* Manifest에서 각 컴포넌트별 프로세스를 설정 가능하다. (application 요소에 프로세스를 설정하게 되면, 하위 컴포넌트는 application에서 설정한 프로세스를 따라가게 된다.)
* 메인 스레드가 종종 UI 스레드라고 불리지만, 메인 스레드가 UI 스레드가 아닌 경우도 발생한다.
* 메인 스레드가 차단되지 않게 주의해야 하고, 작업 시간이 긴 작업의 경우 Worker 스레드로 실행해야 한다.
* 한 개 이상의 스레드에서 불릴 가능성이 있는 메소드는 스레드에 안전하도록 작성해야 한다.(바운드 서비스의 메소드 등)
* 안드로이드는 IPC 메커니즘을 제공한다.

## 참조

[프로세스와 스레드](https://developer.android.com/guide/components/processes-and-threads)