---
title: "Operating System - Process(2)"
date: 2020-07-29
last_modified_at: 2020-07-29
desc: "OS 프로세스(2)"
keywords: "OS,Operating System,Process,프로세스"
permalink: "/os/process2"
categories: 
    - OS
tags: 
    - OS
    - Process
---

## 프로세스 간 통신

운영체제 내에서 실행되는 병행 프로세스들은 독립적이거나 협력적이다. 프로세스가 시스템에서 실행 중인 다른 프로세스들과 데이터를 공유하지 않으면 그 프로세스는 **독립적**이다. 그와 반대로 프로세스가 시스템에서 실행 중인 다른 프로세스들에 영향을 주거나 받는다면 이는 **협력적**인 프로세스이다. 프로세느 협력을 허용하는 환경을 제공하는 데는 몇 가지 이유가 있다.

* 정보 공유 - 여러 응용 프로그램이 동일한 정보에 흥미를 느낄 수 있으므로, 그러한 정보를 병행적으로 접근할 수 있는 환경을 제공해야 한다.
* 계산 가속화 - 만일 특정 태스크를 빨리 실행하고자 한다면, 그 태스크를 서브태스크로 나누어 이들 각각 다른 서브태스크들과 병령로 실행되게 해야 한다. 이러한 가속화는 복수 개의 프로세서를 가진 경우에만 달성할 수 있음을 유의하라
* 모듈성 - 시스템 기능을 별도의 프로세스 또는 스레드로 나누어, 모듈식 형태의 시스템을 구성할 수 있다.

협력적 프로세스들은 데이터를 교환할 수 있는, 즉 서로 데이터를 보내거나 받을 수 있는 프로세스 간 통신(interprocess communication) 기법이 필요하다. 프로세스 간 통신에는 기본적으로 **공유 메모리**와 **메시지 전달**의 두 가지 모델이 있다. 공유 메모리 모델에서는 협력 프로세스들에 의해 공유 되는 메모리의 영역이 구축된다. 프로세스들은 그 영역에 데이터를 읽고 쓰고 함으로써 정보를 교환할 수 있다. 메시지 전달 모델에서는 통신이 협력 프로세스들 사이에 교환되는 메시지를 통하여 이루어진다. 이 두 모델은 아래 이미지와 같다.

![imageProcess]({{ site.url }}{{ site.baseurl }}/assets/images/posts/image_os_ipc_2_model.png)

언급된 두 모델은 운영체제에서 많은 시스템이 두 가지를 모두 구현한다. 메시지 전달 모델은 충돌을 회피할 필요가 없기 때문에 적은 양의 데이터를 교환 하는 데 유용하다. 메시지 전달은 __분산 시스템__ 에서 공유 메모리보다 구현하기 쉬우며, 메시지 전달 시스템은 통상 시스템 콜을 사용하여 구현되므로 커널 간섭 등의 부가적인 시간 소비 작업이 필요하기 때문에 공유 메모리 모델보다 느리다. 공유 메모리 시스템에서는 공유 메모리 영역을 구축할 때만 시스템 콜이 필요하다. 공유 메모리 영역이 구축되면 모든 접근은 일반적인 메모리 접근으로 취급되어 커널의 도움이 필요 없다.

### 공유 메모리 시스템에서의 프로세스간 통신

공유 메모리를 사용하는 프로세스 간 통신에서는 통신하는 프로세스들이 공유 메모리 영역을 구축해야 한다. 통상 공유 메모리 영역은 공유 메모리 세그먼트 생성하는 프로세스의 주소 공간에 위치한다. 이 공유 메모리 세그먼트를 이용하여 통신하고자 하는 다른 프로세스들은 이 세그먼트를 자신의 주소 공간에 추가해야 한다. 일반적으로 운영체제는 한 프로세스가 다른 프로세스의 메모리에 접근하는 것을 금지하며, 공유 메모리는 둘 이상의 프로세스가 이 제약 조건을 제거하는 것에 동의하는 것을 필요로 한다. 그런 후 프로세스들은 공유 영역에 읽고 씀으로써 정보를 교환할 수 있다. 데이터의 형식과 위치는 이들 프로세스에 의해 결정되며 운영체제의 소관이 아니다. 또한 프로세스들은 동시에 동일한 위치에 쓰지 않도록 서로 책임져야 한다.

협력하는 프로세스의 개념을 설명하기 위해서 협력하는 프로세스의 일반적인 패러다임인 **생상자 - 소비자** 문제를 생각해 보기로 하자. **생산자** 프로세스는 정보를 생산하고 **소비자** 프로세스는 정보를 소비한다. 예를 들어, 컴파일러는 어셈블리 코드를 생산하고, 어셈블러는 생산한 어셈블리 코드를 소비한다. 어셈블러는 이어 목적 모듈을 생산할 수 있고, 로더는 이들을 소비한다. 일반적으로 우리는 서버를 **생산자**로 클라이언트를 **소비자**로 생각한다. 예를 들면 웹 서버는 HTML 파일과 이미지와 같은 웹 콘텐츠를 생산하고 이 자원들을 요청한 클라이언트 웹 브라우저가 소비하게 된다.

생산자 - 소비자 문제의 하나의 해결책은 공유 메모리를 사용하는 것이다. 생산자와 소비자 프로세스들이 병행으로 실행되도록 하려면, 생산자가 정보를 채워 넣고 소비자가 소모할 수 있는 항목들의 버퍼가 반드시 사용 가능해야 한다. 이 버퍼는 생산자와 소비자가 공유하는 메모리 영역에 존재하게 된다. 생산자가 한 항목을 생산하고, 그 동안 소비자는 다른 항목을 소비할 수 있다. 생산자와 소비자가 반드시 동기화 되어야 생상되지도 않는 항목들을 소비자가 소비하려고 시도하지 않을 것이다.

이때 두 가지 유형의 버퍼가 사용된다. 무한 버퍼의 생산자 소비자 문제에서는 버퍼의 크기에 실질적인 제한이 없다. 소비자는 새로운 항목을 기다려야 할 수도 있지만, 생산자는 항상 새로운 항목을 생산할 수 있다. 유한 버퍼는 버퍼의 크기가 고정되어 있다고 가정한다. 이 경우 버퍼가 비어 있으면 소비자는 반드시 대기해야 하며, 모든 버퍼가 채워져 있으면 생산자가 대기해야 한다.

유한 버퍼가 공유 메모리를 사용한 프로세스간 통신을 어떻게 분명하게 하는지 살펴보자. 다음 변수들은 생산자와 소비자 프로세스가 공유하는 메모리 영역에 존재한다.

```C
#define BUFFER_SIZE 10

typedef struct {
    ...
} item;

item buffer[BUFFER_SIZE]
int in = 0;
int out = 0;
```

공유 버퍼는 두 개의 논리 포인터 in과 out을 갖는 원형 배열로 구현된다. 변수 in은 버퍼 내에서 다음으로 비어 있는 위치를 가르키며, out은 버퍼 내에서 첫 번째로 채워져 있는 위치를 가리킨다. in == out; 일 때 버퍼는 비어있고 (((in + 1) % BUFFER_SIZE) == out) 이면 버퍼는 가득 차 있다. 생산자와 소비자의 코드가 아래의 그림에 각각 나와 있다. 생산자 프로세스는 next_produced 라는 지역 변수에 다음번 생산되는 item을 저장하고 있다. 소비자 코드는 next_consumed 라는 지역 변수에 다음번 소비되는 item을 저장하고 있다.

```C
item next_produced;

while (true) {
    /* produce an item in next_produced */

    while (((in + 1) % BUFFER_SIZE) == out)
        ;/* do nothing */

    buffer[in] = next_produced;
    in = (in + 1) % BUFFER_SIZE
}
```

```C
item next_consumed;

while (true) {
    while (in == out)
        ; /* do nothing */

    next_consumed = buffer[out];
    out = (out + 1) % BUFFER_SIZE;

    /* consume the item in next_consumed */
}

```