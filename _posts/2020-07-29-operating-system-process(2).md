---
title: "Operating System - Process(2)"
date: 2020-07-29
last_modified_at: 2020-07-29
desc: "OS 프로세스(2)"
keywords: "OS,Operating System,Process,프로세스"
permalink: "/os/process2"
categories: 
    - OS
tags: 
    - OS
    - Process
---

## 프로세스 간 통신

운영체제 내에서 실행되는 병행 프로세스들은 독립적이거나 협력적이다. 프로세스가 시스템에서 실행 중인 다른 프로세스들과 데이터를 공유하지 않으면 그 프로세스는 **독립적**이다. 그와 반대로 프로세스가 시스템에서 실행 중인 다른 프로세스들에 영향을 주거나 받는다면 이는 **협력적**인 프로세스이다. 프로세느 협력을 허용하는 환경을 제공하는 데는 몇 가지 이유가 있다.

* 정보 공유 - 여러 응용 프로그램이 동일한 정보에 흥미를 느낄 수 있으므로, 그러한 정보를 병행적으로 접근할 수 있는 환경을 제공해야 한다.
* 계산 가속화 - 만일 특정 태스크를 빨리 실행하고자 한다면, 그 태스크를 서브태스크로 나누어 이들 각각 다른 서브태스크들과 병령로 실행되게 해야 한다. 이러한 가속화는 복수 개의 프로세서를 가진 경우에만 달성할 수 있음을 유의하라
* 모듈성 - 시스템 기능을 별도의 프로세스 또는 스레드로 나누어, 모듈식 형태의 시스템을 구성할 수 있다.

협력적 프로세스들은 데이터를 교환할 수 있는, 즉 서로 데이터를 보내거나 받을 수 있는 프로세스 간 통신(interprocess communication) 기법이 필요하다. 프로세스 간 통신에는 기본적으로 **공유 메모리**와 **메시지 전달**의 두 가지 모델이 있다. 공유 메모리 모델에서는 협력 프로세스들에 의해 공유 되는 메모리의 영역이 구축된다. 프로세스들은 그 영역에 데이터를 읽고 쓰고 함으로써 정보를 교환할 수 있다. 메시지 전달 모델에서는 통신이 협력 프로세스들 사이에 교환되는 메시지를 통하여 이루어진다. 이 두 모델은 아래 이미지와 같다.

![imageProcess]({{ site.url }}{{ site.baseurl }}/assets/images/posts/image_os_ipc_2_model.png)

언급된 두 모델은 운영체제에서 많은 시스템이 두 가지를 모두 구현한다. 메시지 전달 모델은 충돌을 회피할 필요가 없기 때문에 적은 양의 데이터를 교환 하는 데 유용하다. 메시지 전달은 __분산 시스템__ 에서 공유 메모리보다 구현하기 쉬우며, 메시지 전달 시스템은 통상 시스템 콜을 사용하여 구현되므로 커널 간섭 등의 부가적인 시간 소비 작업이 필요하기 때문에 공유 메모리 모델보다 느리다. 공유 메모리 시스템에서는 공유 메모리 영역을 구축할 때만 시스템 콜이 필요하다. 공유 메모리 영역이 구축되면 모든 접근은 일반적인 메모리 접근으로 취급되어 커널의 도움이 필요 없다.

### 공유 메모리 시스템에서의 프로세스간 통신

공유 메모리를 사용하는 프로세스 간 통신에서는 통신하는 프로세스들이 공유 메모리 영역을 구축해야 한다. 통상 공유 메모리 영역은 공유 메모리 세그먼트 생성하는 프로세스의 주소 공간에 위치한다. 이 공유 메모리 세그먼트를 이용하여 통신하고자 하는 다른 프로세스들은 이 세그먼트를 자신의 주소 공간에 추가해야 한다. 일반적으로 운영체제는 한 프로세스가 다른 프로세스의 메모리에 접근하는 것을 금지하며, 공유 메모리는 둘 이상의 프로세스가 이 제약 조건을 제거하는 것에 동의하는 것을 필요로 한다. 그런 후 프로세스들은 공유 영역에 읽고 씀으로써 정보를 교환할 수 있다. 데이터의 형식과 위치는 이들 프로세스에 의해 결정되며 운영체제의 소관이 아니다. 또한 프로세스들은 동시에 동일한 위치에 쓰지 않도록 서로 책임져야 한다.

협력하는 프로세스의 개념을 설명하기 위해서 협력하는 프로세스의 일반적인 패러다임인 **생상자 - 소비자** 문제를 생각해 보기로 하자. **생산자** 프로세스는 정보를 생산하고 **소비자** 프로세스는 정보를 소비한다. 예를 들어, 컴파일러는 어셈블리 코드를 생산하고, 어셈블러는 생산한 어셈블리 코드를 소비한다. 어셈블러는 이어 목적 모듈을 생산할 수 있고, 로더는 이들을 소비한다. 일반적으로 우리는 서버를 **생산자**로 클라이언트를 **소비자**로 생각한다. 예를 들면 웹 서버는 HTML 파일과 이미지와 같은 웹 콘텐츠를 생산하고 이 자원들을 요청한 클라이언트 웹 브라우저가 소비하게 된다.

생산자 - 소비자 문제의 하나의 해결책은 공유 메모리를 사용하는 것이다. 생산자와 소비자 프로세스들이 병행으로 실행되도록 하려면, 생산자가 정보를 채워 넣고 소비자가 소모할 수 있는 항목들의 버퍼가 반드시 사용 가능해야 한다. 이 버퍼는 생산자와 소비자가 공유하는 메모리 영역에 존재하게 된다. 생산자가 한 항목을 생산하고, 그 동안 소비자는 다른 항목을 소비할 수 있다. 생산자와 소비자가 반드시 동기화 되어야 생상되지도 않는 항목들을 소비자가 소비하려고 시도하지 않을 것이다.

이때 두 가지 유형의 버퍼가 사용된다. 무한 버퍼의 생산자 소비자 문제에서는 버퍼의 크기에 실질적인 제한이 없다. 소비자는 새로운 항목을 기다려야 할 수도 있지만, 생산자는 항상 새로운 항목을 생산할 수 있다. 유한 버퍼는 버퍼의 크기가 고정되어 있다고 가정한다. 이 경우 버퍼가 비어 있으면 소비자는 반드시 대기해야 하며, 모든 버퍼가 채워져 있으면 생산자가 대기해야 한다.

유한 버퍼가 공유 메모리를 사용한 프로세스간 통신을 어떻게 분명하게 하는지 살펴보자. 다음 변수들은 생산자와 소비자 프로세스가 공유하는 메모리 영역에 존재한다.

```C
#define BUFFER_SIZE 10

typedef struct {
    ...
} item;

item buffer[BUFFER_SIZE]
int in = 0;
int out = 0;
```

공유 버퍼는 두 개의 논리 포인터 in과 out을 갖는 원형 배열로 구현된다. 변수 in은 버퍼 내에서 다음으로 비어 있는 위치를 가르키며, out은 버퍼 내에서 첫 번째로 채워져 있는 위치를 가리킨다. in == out; 일 때 버퍼는 비어있고 (((in + 1) % BUFFER_SIZE) == out) 이면 버퍼는 가득 차 있다. 생산자와 소비자의 코드가 아래의 그림에 각각 나와 있다. 생산자 프로세스는 next_produced 라는 지역 변수에 다음번 생산되는 item을 저장하고 있다. 소비자 코드는 next_consumed 라는 지역 변수에 다음번 소비되는 item을 저장하고 있다.

```C
item next_produced;

while (true) {
    /* produce an item in next_produced */

    while (((in + 1) % BUFFER_SIZE) == out)
        ;/* do nothing */

    buffer[in] = next_produced;
    in = (in + 1) % BUFFER_SIZE
}
```

```C
item next_consumed;

while (true) {
    while (in == out)
        ; /* do nothing */

    next_consumed = buffer[out];
    out = (out + 1) % BUFFER_SIZE;

    /* consume the item in next_consumed */
}

```

### 메시지 전달 시스템에서 프로스세 간 통신

메시지 전달 방식은 동일한 주소 공간을 공유하지 않고도 프로세스들이 통신 하고, 그들의 동작을 동기화할 수 있도록 허용하는 기법을 제공한다. 메시지 전달 방식은 통신하는 프로세스들이 네트워크에 의해 연결된 다른 컴퓨터들에 존재할 수 있는 분산 환경에서 특히 유용하다. 한 예로 WWW에 사용되는 chat 프로그램은 서로 메시지를 교환하여 통신하도록 설계될 수 있다.

메시지 전달 시슽메은 최소한 두 가지 연산을 제공한다.

* send(message)
* receive(message)

프로세스가 보낸 메시지는 고정 길이일 수도 있고 가변 길이일 수도 있다. 고정 길이 메시지만 보낼 수 있다면, 시스템 수준의 구현은 직선적이다. 그렇지만, 이러한 제한은 프로그래밍 작업을 더욱 힘들게 한다. 반면에, 가변 길이 메시지는 보다 복잡한 시스템 수준의 구현이 있어야 하지만, 프로그래밍 작업은 더 간단해진다. 이러한 일은 운영체제 설계 전반에 걸쳐 흔히 볼 수 있는 교환이다.

만약 프로세스 P와 Q가 통신을 원하면, 반드시 서로 메시지를 보내고 받아야 한다. 이들 사이에 통신 연결이 설정되어 있엉 ㅑ한다. 이 연결은 다양한 방법으로 구현할 수 있다. 여기서 알아볼 것은 물리적인 구현이 아니라 논리적인 구현이다. 하나의 링크와 send()/receive() 연산을 논리적으로 구현하는 다수의 방법은 아래와 같다.

* 직접 또는 간접 통신
* 동기식 또는 비동기식 통신
* 자동 또는 명시적 버퍼링

### 네이밍

통신을 원하는 프로세스들은 서로를 가리킬 방법이 있어야 한다. 이들은 간접 통신 또는 직접 통신을 사용할 수 있다. 직접 토신하에서, 통신을 원하는 각 프로세스는 통신의 수신자 또는 송신자의 이름을 명시해야 한다. 이 기법에서 send(), receive() 함수들은 다음과 같이 정의해야 한다.

* send(P, message) - 프로세스 P에 메시지를 전송한다.
* receive(Q, message) - 프로세스 Q로부터 메시지를 수신한다.

이 기법의 통신 연결은 다음의 특성을 가진다.

* 통신을 원하는 각 프로세스의 쌍들 사이에 연결이 자동으로 구축된다. 프로세스들은 통신하기 위해 상대방의 ID만 알면 된다.
* 연결은 정확히 두 프로세스 사이에만 연관된다.
* 통신하는 프로세스들의 각 쌍 사이에는 정확하게 하나의 연결이 존재해야 한다.

이 기법은 주소 방식에서 대칭성을 보인다. 즉, 송신자와 수신자 프로세스 모두 통신하려면 상대방의 이름을 제시해야 한다. 이 기법의 변형으로는 주소 지정 시에 비대칭이 있다. 송신자만 수신자 이름을 지명하며, 수신자는 송신자의 이름을 제시할 필요가 없다. 이 기법에서 send()와 receive() 함수들은 다음과 같이 정의 한다.

* send(P, message) - 메시지를 프로세스 P에 전송한다.
* receive(id, message) - 임의의 프로세스로 부터 메시지를 수신한다. 변수 id는 통신을 발생시킨 프로세스의 이름으로 설정된다.