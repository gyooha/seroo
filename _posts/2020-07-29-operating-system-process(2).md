---
title: "Operating System - Process(2)"
date: 2020-07-29
last_modified_at: 2020-07-29
desc: "OS 프로세스(2)"
keywords: "OS,Operating System,Process,프로세스"
permalink: "/os/process2"
categories: 
    - OS
tags: 
    - OS
    - Process
---

## 프로세스 간 통신

운영체제 내에서 실행되는 병행 프로세스들은 독립적이거나 협력적이다. 프로세스가 시스템에서 실행 중인 다른 프로세스들과 데이터를 공유하지 않으면 그 프로세스는 **독립적**이다. 그와 반대로 프로세스가 시스템에서 실행 중인 다른 프로세스들에 영향을 주거나 받는다면 이는 **협력적**인 프로세스이다. 프로세느 협력을 허용하는 환경을 제공하는 데는 몇 가지 이유가 있다.

* 정보 공유 - 여러 응용 프로그램이 동일한 정보에 흥미를 느낄 수 있으므로, 그러한 정보를 병행적으로 접근할 수 있는 환경을 제공해야 한다.
* 계산 가속화 - 만일 특정 태스크를 빨리 실행하고자 한다면, 그 태스크를 서브태스크로 나누어 이들 각각 다른 서브태스크들과 병령로 실행되게 해야 한다. 이러한 가속화는 복수 개의 프로세서를 가진 경우에만 달성할 수 있음을 유의하라
* 모듈성 - 시스템 기능을 별도의 프로세스 또는 스레드로 나누어, 모듈식 형태의 시스템을 구성할 수 있다.

협력적 프로세스들은 데이터를 교환할 수 있는, 즉 서로 데이터를 보내거나 받을 수 있는 프로세스 간 통신(interprocess communication) 기법이 필요하다. 프로세스 간 통신에는 기본적으로 **공유 메모리**와 **메시지 전달**의 두 가지 모델이 있다. 공유 메모리 모델에서는 협력 프로세스들에 의해 공유 되는 메모리의 영역이 구축된다. 프로세스들은 그 영역에 데이터를 읽고 쓰고 함으로써 정보를 교환할 수 있다. 메시지 전달 모델에서는 통신이 협력 프로세스들 사이에 교환되는 메시지를 통하여 이루어진다. 이 두 모델은 아래 이미지와 같다.

![imageProcess]({{ site.url }}{{ site.baseurl }}/assets/images/posts/image_os_ipc_2_model.png)

언급된 두 모델은 운영체제에서 많은 시스템이 두 가지를 모두 구현한다. 메시지 전달 모델은 충돌을 회피할 필요가 없기 때문에 적은 양의 데이터를 교환 하는 데 유용하다. 메시지 전달은 __분산 시스템__ 에서 공유 메모리보다 구현하기 쉬우며, 메시지 전달 시스템은 통상 시스템 콜을 사용하여 구현되므로 커널 간섭 등의 부가적인 시간 소비 작업이 필요하기 때문에 공유 메모리 모델보다 느리다. 공유 메모리 시스템에서는 공유 메모리 영역을 구축할 때만 시스템 콜이 필요하다. 공유 메모리 영역이 구축되면 모든 접근은 일반적인 메모리 접근으로 취급되어 커널의 도움이 필요 없다.

### 공유 메모리 시스템에서의 프로세스간 통신

공유 메모리를 사용하는 프로세스 간 통신에서는 통신하는 프로세스들이 공유 메모리 영역을 구축해야 한다. 통상 공유 메모리 영역은 공유 메모리 세그먼트 생성하는 프로세스의 주소 공간에 위치한다. 이 공유 메모리 세그먼트를 이용하여 통신하고자 하는 다른 프로세스들은 이 세그먼트를 자신의 주소 공간에 추가해야 한다. 일반적으로 운영체제는 한 프로세스가 다른 프로세스의 메모리에 접근하는 것을 금지하며, 공유 메모리는 둘 이상의 프로세스가 이 제약 조건을 제거하는 것에 동의하는 것을 필요로 한다. 그런 후 프로세스들은 공유 영역에 읽고 씀으로써 정보를 교환할 수 있다. 데이터의 형식과 위치는 이들 프로세스에 의해 결정되며 운영체제의 소관이 아니다. 또한 프로세스들은 동시에 동일한 위치에 쓰지 않도록 서로 책임져야 한다.

협력하는 프로세스의 개념을 설명하기 위해서 협력하는 프로세스의 일반적인 패러다임인 **생상자 - 소비자** 문제를 생각해 보기로 하자. **생산자** 프로세스는 정보를 생산하고 **소비자** 프로세스는 정보를 소비한다. 예를 들어, 컴파일러는 어셈블리 코드를 생산하고, 어셈블러는 생산한 어셈블리 코드를 소비한다. 어셈블러는 이어 목적 모듈을 생산할 수 있고, 로더는 이들을 소비한다. 일반적으로 우리는 서버를 **생산자**로 클라이언트를 **소비자**로 생각한다. 예를 들면 웹 서버는 HTML 파일과 이미지와 같은 웹 콘텐츠를 생산하고 이 자원들을 요청한 클라이언트 웹 브라우저가 소비하게 된다.

생산자 - 소비자 문제의 하나의 해결책은 공유 메모리를 사용하는 것이다. 생산자와 소비자 프로세스들이 병행으로 실행되도록 하려면, 생산자가 정보를 채워 넣고 소비자가 소모할 수 있는 항목들의 버퍼가 반드시 사용 가능해야 한다. 이 버퍼는 생산자와 소비자가 공유하는 메모리 영역에 존재하게 된다. 생산자가 한 항목을 생산하고, 그 동안 소비자는 다른 항목을 소비할 수 있다. 생산자와 소비자가 반드시 동기화 되어야 생상되지도 않는 항목들을 소비자가 소비하려고 시도하지 않을 것이다.

이때 두 가지 유형의 버퍼가 사용된다. 무한 버퍼의 생산자 소비자 문제에서는 버퍼의 크기에 실질적인 제한이 없다. 소비자는 새로운 항목을 기다려야 할 수도 있지만, 생산자는 항상 새로운 항목을 생산할 수 있다. 유한 버퍼는 버퍼의 크기가 고정되어 있다고 가정한다. 이 경우 버퍼가 비어 있으면 소비자는 반드시 대기해야 하며, 모든 버퍼가 채워져 있으면 생산자가 대기해야 한다.

유한 버퍼가 공유 메모리를 사용한 프로세스간 통신을 어떻게 분명하게 하는지 살펴보자. 다음 변수들은 생산자와 소비자 프로세스가 공유하는 메모리 영역에 존재한다.

```C
#define BUFFER_SIZE 10

typedef struct {
    ...
} item;

item buffer[BUFFER_SIZE]
int in = 0;
int out = 0;
```

공유 버퍼는 두 개의 논리 포인터 in과 out을 갖는 원형 배열로 구현된다. 변수 in은 버퍼 내에서 다음으로 비어 있는 위치를 가르키며, out은 버퍼 내에서 첫 번째로 채워져 있는 위치를 가리킨다. in == out; 일 때 버퍼는 비어있고 (((in + 1) % BUFFER_SIZE) == out) 이면 버퍼는 가득 차 있다. 생산자와 소비자의 코드가 아래의 그림에 각각 나와 있다. 생산자 프로세스는 next_produced 라는 지역 변수에 다음번 생산되는 item을 저장하고 있다. 소비자 코드는 next_consumed 라는 지역 변수에 다음번 소비되는 item을 저장하고 있다.

```C
item next_produced;

while (true) {
    /* produce an item in next_produced */

    while (((in + 1) % BUFFER_SIZE) == out)
        ;/* do nothing */

    buffer[in] = next_produced;
    in = (in + 1) % BUFFER_SIZE
}
```

```C
item next_consumed;

while (true) {
    while (in == out)
        ; /* do nothing */

    next_consumed = buffer[out];
    out = (out + 1) % BUFFER_SIZE;

    /* consume the item in next_consumed */
}

```

### 메시지 전달 시스템에서 프로스세 간 통신

메시지 전달 방식은 동일한 주소 공간을 공유하지 않고도 프로세스들이 통신 하고, 그들의 동작을 동기화할 수 있도록 허용하는 기법을 제공한다. 메시지 전달 방식은 통신하는 프로세스들이 네트워크에 의해 연결된 다른 컴퓨터들에 존재할 수 있는 분산 환경에서 특히 유용하다. 한 예로 WWW에 사용되는 chat 프로그램은 서로 메시지를 교환하여 통신하도록 설계될 수 있다.

메시지 전달 시스템은 최소한 두 가지 연산을 제공한다.

* send(message)
* receive(message)

프로세스가 보낸 메시지는 고정 길이일 수도 있고 가변 길이일 수도 있다. 고정 길이 메시지만 보낼 수 있다면, 시스템 수준의 구현은 직선적이다. 그렇지만, 이러한 제한은 프로그래밍 작업을 더욱 힘들게 한다. 반면에, 가변 길이 메시지는 보다 복잡한 시스템 수준의 구현이 있어야 하지만, 프로그래밍 작업은 더 간단해진다. 이러한 일은 운영체제 설계 전반에 걸쳐 흔히 볼 수 있는 교환이다.

만약 프로세스 P와 Q가 통신을 원하면, 반드시 서로 메시지를 보내고 받아야 한다. 이들 사이에 통신 연결이 설정되어 있어야한다. 이 연결은 다양한 방법으로 구현할 수 있다. 여기서 알아볼 것은 물리적인 구현이 아니라 논리적인 구현이다. 하나의 링크와 send()/receive() 연산을 논리적으로 구현하는 다수의 방법은 아래와 같다.

* 직접 또는 간접 통신
* 동기식 또는 비동기식 통신
* 자동 또는 명시적 버퍼링

### 네이밍

통신을 원하는 프로세스들은 서로를 가리킬 방법이 있어야 한다. 이들은 간접 통신 또는 직접 통신을 사용할 수 있다. **직접 통신**에서 통신을 원하는 각 프로세스는 통신의 수신자 또는 송신자의 이름을 명시해야 한다. 이 기법에서 send(), receive() 함수들은 다음과 같이 정의해야 한다.

* send(P, message) - 프로세스 P에 메시지를 전송한다.
* receive(Q, message) - 프로세스 Q로부터 메시지를 수신한다.

이 기법의 통신 연결은 다음의 특성을 가진다.

* 통신을 원하는 각 프로세스의 쌍들 사이에 연결이 자동으로 구축된다. 프로세스들은 통신하기 위해 상대방의 id만 알면 된다.
* 연결은 정확히 두 프로세스 사이에만 연관된다.
* 통신하는 프로세스들의 각 쌍 사이에는 정확하게 하나의 연결이 존재해야 한다.

이 기법은 주소 방식에서 대칭성을 보인다. 즉, 송신자와 수신자 프로세스 모두 통신하려면 상대방의 이름을 제시해야 한다. 이 기법의 변형으로는 주소 지정 시에 비대칭이 있다. __송신자만 수신자 이름을 지명하며, 수신자는 송신자의 이름을 제시할 필요가 없다.__ 이 기법에서 send()와 receive() 함수들은 다음과 같이 정의한다.

* send(P, message) - 메시지를 프로세스 P에 전송한다.
* receive(id, message) - 임의의 프로세스로 부터 메시지를 수신한다. 변수 id는 통신을 발생시킨 프로세스의 이름으로 설정된다.

이들 기법 모두 프로세스를 지정하는 방식 때문에 모듈성을 제한한다는 것이 단점이다. 프로세스의 이름을 바꾸면 모든 다른 프로세스 지정 부분을 검사할 필요가 있을 수 있다. 옛 이름들에 대한 모든 참조를 찾아서 새로운 이름으로 변경해야 할 것이다. 일반적으로 이러한 하드코딩 기법은, 이 상황에서 id를 명시적으로 표시해야 한다. 다음에 설명할 간접적인 방식에 비해 바람직하지 않다.

**간접 통신**에서 메시지들은 **메일박스** 또는 **포트**로 송신되고, 수신된다. 메일박스는 추상적으로 프로세스들에 의해 메시지들이 넣어지고, 메시지들이 제거될 수 있는 객체로 볼 수 있다. 각 메일박스는 고유의 id를 가진다. 예를 들어 POSIX 메시지 큐는 메일박스를 식별하기 위하여 정수 값을 사용한다. 이 기법에서 프로세스는 다수의 상이한 메일박스를 통해 다른 프로세스들과 통신할 수 있다. 두 프로세스들이 공유 메일박스를 가질 때만 이들 프로세스가 통신할 수 있다. send()와 receive() 함수들은 다음과 같이 정의할 수 있다.

* send(A, message) - 메시지를 메일박스 A로 전송한다.
* receive(A, message) - 메시지를 메일박스 A로부터 수신한다.

이 방법에서 통신 연결은 다음의 성질을 가진다.

* 한 쌍의 프로세스들 사이의 연결은 이들 프로세스가 공유 메일박스를 가질 때만 구축된다.
* 연결은 두 개 이상의 프로세스들과 연관될 수 있다.
* 통신하고 있는 각 프로세스 사이에는 다수의 서로 다른 연결이 존재할 수 있고, 각 연결은 하나의 메일박스에 대응된다.

프로세스 P1, P2, P3가 모두 메일박스 A를 공유한다고 가정하자. 프로세스 P1은 메시지를 A에 송신하고, P2, P3는 각각 A로부터 receive()를 실행한다. 어느 프로세스가 P1이 보낸 메시지를 수신하는가? 이 문제에 대한 답은 앞으로 선택할 기법에 좌우된다.

* 하나의 링크는 최대 두 개의 프로세스와 연관되도록 허용한다.
* 한 순간에 하나의 프로세스가 receive() 연산을 실행하도록 허용한다.
* 어느 프로세스가 메시지를 수신할 것인지 시스템이 임의로 선택하도록 한다. 시스템이 어느 프로세스가 수신할 것인지를 선택하는 알고리즘을 정의할 수 있다. 시스템은 송신자에게 수신자를 알려 줄 수 있다.

메일박스는 한 프로세스 또는 운영체제에 의해 소유될 수 있다. 메일박스가 한 프로세스에 의해 소유된다면, 각 메일박스가 고유한 소유자를 가지고 있기 때문에, 소유자와 메일박스의 사용자를 구분할 수 있다. 그러므로 __이 메일박스로 보내진 메시지를 어느 프로세스가 수신할지에 대한 혼란이 있을 수 없다.__ 메일박스를 소유하고 있는 프로세스가 종료될 때, 메일박스는 사라진다. 그 후 이 메일박스로 메시지를 송신하는 모든 프로세스는 더는 메일박스가 존재하지 않는다는 사실을 반드시 통보받아야 한다.

반면에, 운영체제가 소유한 메일박스는 자체적으로 존재한다. 이것은 독립적인 것으로 어떤 특정한 프로세스에 포함되지 않는다. 운영체제는 한 프로세스에 아래의 액션을 할 수 있도록 허용하는 기법을 반드시 제공해야 한다.

* 새로운 메일박스를 생성한다.
* 메일박스를 통해 메시지를 송신하고 수신한다.
* 메일박스를 생성한다.

새로운 메일박스를 생성하는 프로세스는 디폴트로 메일박스의 소유자가 된다. 초기에는, 소유자만이 이 메일박스를 통해 메시지를 수신할 수 있는 유일한 프로세스이다. 그러나 소유권과 수신권은 적절한 시스템 콜을 통해 다른 프로세스에 전달될 수 있다. 

> 물론 이런 규칙으로 인해 메일박스마다 복수의 수신자를 낳을 수 있다.

### 동기화

프로세스 간 통신은 send와 receive 함수 호출에 의해 발생한다. 각 함수를 구현하기 위한 서로 다른 설계 옵션이 있다. 메시지 전달은 블록킹이거나 논블록킹 방식으로 전달된다. 이 두 방식은 각각 동기식, 비동기식이라고도 알려져 있다.

* 블록킹 전송 - 송신하는 프로세스는 메시지가 수신 프로세스 또는 메일박스에 의해 수신될 때까지 블록된다.
* 논블록킹 전송 - 송신하는 프로세스가 메시지를 보내고 작업을 재시작한다.
* 블록킹 수신 - 메시지가 이용 가능할 때까지 수신 프로세스가 블록된다.
* 논블록킹 수신 - 송신하는 프로세스가 유효한 메시지 또는 null을 받는다.

send()와 receive()의 다른 조합도 가능하다. send()와 receive()가 모두 블록킹일 때, 우리는 송신자와 수신자 간의 랑데부를 하게 된다. 블록킹 send()와 receive()를 사용한다면 생산자와 소비자 문제에 대한 해결책은 사소한 문제가 된다. 생산자는 단순히 블록킹 send()를 호출하고 메시지가 수신자 또는 메일박스에 전달될 때까지 기다린다. 유사하게 소비자가 receive()를 호출하면 메시지가 전달될 때까지 블록된다. 

```C
message next_produced;

while(true) {
    /* produce an item in next_produced */

    send(next_produced)
}
```

```C
message next_consumed;

while (true) {
    receive(next_consumed)

    /* consume the item in next_consumed */
}
```

### 버퍼링

통신이 직접적이든 간접적이든 간에, __통신하는 프로세스들에 의해 교환되는 메시지는 임시 큐에 들어 있다.__ 기본적으로 이러한 큐를 구현하는 방식은 세 가지가 있다.

* 무용량 - 큐의 최대 길이가 0이다. 즉, 메시지를 저장할 공간이 없으므로 이 경우에, **송신자는 수신자가 메시지를 수신할 때까지 기다려야 한다.**

* 유한 용량 - 큐는 유한한 길이 n을 가진다. 즉, 최대 n개의 메시지가 그 안에 들어 있을 수 있다. 새로운 메시지가 전송될 때 큐가 꽉 찬 것이 아니라면, 메시지는 큐에 놓이며, 송신자는 대기하지 않고 실행을 계속한다. 하지만 큐가 꽉 차게 되면, 송신자는 큐 안의 공간이 이용 가능할 때까지 반드시 블록되어야 한다.

* 무한 용량 - 큐는 잠재적으로 무한한 길이를 가진다. 따라서 메시지들이 얼마든지 큐 안에 대기할 수 있다. 송신자는 절대 블록되지 않는다.

> 무용량의 경우 때때로 버퍼가 없는 메시지 시스템 이라고 불린다. 다른 경우는 자동 버퍼링이라 불린다.

### POSIX 공유 메모리

공유 메모리와 메시지 전달을 포함하여 POSIX 시스템을 위한 다수의 IPC 기법이 사용 가능하다. 여기서 공유 메모리를 위한 POSIX API를 살펴보자.

POSIX 공유 메모리는 메모리 - 맵핑 파일을 사용하여 구현된다. 메모리 - 맵핑 파일은 공유 메모리의 특정 영역을 파일과 연관시킨다. 프로세스는 먼저 아래와 같으 __shm_open()__ 시스템 콜을 사용하여 공유 메모리 객체를 생성해야 한다.

```c
fd = shm_open(name, O_CREATE | O_RDWR, 0666);
```

첫 번째 인자는 공유 메모리 객체의 이름을 지정한다. 공유 메모리에 접근하고자 하는 프로세스는 이 이름을 통하여 객체를 언급한다. 두 번째 인자는 객체가 존재하지 않으면 생성되고 객체는 읽기와 쓰기가 가능한 상태로 열린다는것을 나타낸다. 마지막 인자는 공유 메모리 객체에 파일 - 접근 허가권을 부여한다. shm_open() 시스템 콜이 성공하면 공유 메모리 객체를 나타내는 정수형 파일 설명자를 반환한다.

객체가 설정되면 __ftruncate()__ 함수를 사용하여 객체의 크기를 바이트 단위로 설정한다. 다음과 같은 호출은 객체의 크기를 4096바이트로 설정한다

```c
ftruncate(fd, 4096)
```

마지막으로 __mmap()__ 함수가 공유 메모리 객체를 포함하는 메모리 - 맵핑 파일을 구축한다. mmap() 함수는 공유 메모리 객체에 접근할 때 사용될 메모리 - 맵핑 파일의 포인터를 반환한다.

> 여기서 예제는 생성자 소비자 모델을 사용한다. 생성자는 공유 메모리 객체를 구축하고, 공유 메모리에 데이터를 쓰며 소비자는 공유 메모리에서 데이터를 읽는다.

아래의 예제는 OS라고 명명된 공유 메모리 객체를 생성하고 문자열 "Hello World!"를 공유 메모리에 쓴다. 프로그램은 지정된 크기의 공유 메모리 객체를 메모리에 맵핑하고 객체에 쓰기 권한을 부여한다. MAP_SHARED 플래그는 공유 메모리 객체에 변경이 발생하면 객체를 공유하는 모든 프로세스가 최신의 값을 접근하게 된다는 것을 지정한다. 공유 메모리 객체에 쓰기 작업을 할 때 sprintf() 함수를 호출하고 출력 형식이 완성된 문자열은 ptr이 가리키는 공유 메모리 객체에 쓰인다는것을 주의하라. 쓰기 작업이 성공하면 쓰인 바이트 수만큼 포인터를 반드시 증가시켜야 한다.

```c

/* include groups */

int main() {
    const int SIZE = 4096;
    const char *name = "OS";
    const char *message_0 = "Hello";
    const char *message_1 = "World!";

    int fd;
    char *ptr;

    fd = shm_open(name, O_CREATE | O_RDWR, 0666);

    ftruncate(fd, SIZE);

    ptr = (char *) mmap(0, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);

    sprintf(ptr, "%s", message_0)
    ptr += strlen(message_0)
    sprintf(ptr, "%s", message_1)
    ptr += strlen(message_1)

    return 0
}

```

아래의 예제 소비자 프로세스는 공유 메모리의 내용을 읽고 출력한다. 또한 소비자는 __shm_unlink()__ 함수를 호출하여 접근이 끝난 공유 메모리를 제거한다.

```c

/* include groups */

int main() {
    const int SIZE = 4096;
    const char *name = "OS";
    
    int fd;
    char *ptr;

    fd = shm_open(name, O_RDONLY, 0666);

    ptr = (char *) mmap(0, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0)

    printf("%s", (char *)ptr)

    shm_unlink(name);

    return 0
}

```

