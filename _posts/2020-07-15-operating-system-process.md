---
title: "Operating System - Process"
date: 2020-07-15
last_modified_at: 2020-07-15
desc: "OS 프로세스"
keywords: "OS,Operating System,Process,프로세스"
permalink: "/os/process"
categories: 
    - OS
tags: 
    - OS
    - Process
---

# 프로세스

비공식적으로 프로세스는 실행 중인 프로그램이다. 프로세스의 현재 활동의 상태는 프로그램 카운터(PC) 값과 프로세서 레지스터의 내용으로 나타낸다. 프로세스의 메모리 배치는 일반적으로 여러 섹션으로 구성되어 있으며 아래와 같다.

![imageProcess]({{ site.url }}{{ site.baseurl }}/assets/images/posts/image_os_process_01.jpg)

위의 이미지와 같이 프로세스는 아래와 같은 섹션들을 포함하고 있다.

* 힙 - 프로그램 실행 중에 동적으로 할당되는 메모리
* 스택 - 함수를 호출할 때 임시 데이터 저장장소(함수의 매개변수, 복귀 주소, 지역 변수 등등)
* 데이터 - 전역 변수
* 텍스트 - 실행 코드

텍스트 및 데이터 섹션은 크기가 고정되어있기 떄문에 프로그램 실행 시간 동안 크기가 변하지 않는다. 그러나 힙, 스택 섹션은 프로그램 실행 중에 동적으로 변동된다.

## 힙, 스택

### 스택 

함수가 호출될 때마다 함수의 매개변수, 지역 변수 및 복귀 주소를 포함하는 활성화 레코드(activiation record)가 스택에 푸쉬(PUSH) 된다. 함수로부터 제어가 되돌아오면 스택에서 활성화 레코드가 팝(POP) 된다.

### 힙

스택과 마찬가지로 메모리가 동적으로 할당됨에 따라 힙이 커지고 메모리가 시스템에 반환되면 축소된다.

스택 및 힙 섹션이 서로의 방향으로 커지더라도 운영체제는 서로 겹치지 않도록 조절해줘야 한다.

> 프로그램 그 자체는 프로세스가 아니다. 프로그램은 명령어 리스트를 내용으로 가진 디스크에 저장된 파일과 같은 수동적인 존재이다. 이와 반대로 프로세스는 다음에 실행할 명령어를 지정하는 프로그램 카운터와 관련 자원의 집합을 가진 능동적인 존재이다. **결론은 실행 파일이 메모리에 적재될 때 프로그램은 프로세스가 된다.**

## 프로세스 상태

프로세스는 실행되면서 상태가 수시로 변한다. 프로세스의 상태는 부분적으로 그 프로세스의 현재의 활동에 따라서 정의된다. 프로세스의 상태는 아래와 같다.

* 새로운(new) - 프로세스가 생성 중이다.
* 실행(running) - 명령어들이 실행되고 있다.
* 대기(waiting) - 프로세스가 어떤 이벤트가 일어나기를 기다린다.
* 준비(ready) - 프로세스가 프로세서에 할당되기를 기다린다.
* 종료(terminated) - 프로세스의 실행이 종료되었다.

> 상태의 이름은 운영체제마다 다르므로 임의적이다. 그렇지만, 모든 시스템에서 프로세스의 상태를 찾아볼 수 있다. 또한 어떤 운영체제는 프로세스의 상태를 더욱 자세하게 묘사하여 구별한다. **결론은 어느 한순간에 한 프로세서 코어에서 오직 하나의 프로세스만 실행된다는 것을 인식하는것이 중요하다.**

> 많은 프로세스가 준비완료 및 대기 상태에 있을 수 있다.

## 프로세스 제어 블록(PCB: Process Control Block)

각 프로세스는 운영체제에서 PCB에 의해 표현된다. PCB는 특정 프로세스와 연관된 여러 정보를 수록하며, 다음과 같은 것들을 포함한다.

* 프로세스 상태 - new, ready, running, waiting, halted 등이 있다.
* 프로그램 카운터 - 프로그램 카운터는 이 프로세스가 다음에 실행할 명령어의 주소를 가리킨다.
* CPU 레지스터들 - CPU 레지스터는 컴퓨터의 구조에 따라 다양한 수와 유형을 가진다. 레지스터에는 누산기, 인덱스, 스택, 범용 레지스터들과 상태 코드 정보가 포함된다. 프로그램 카운터와 함께 이 상태 정보는, 나중에 프로세스가 다시 스케줄 될 때 올바르게 실행되도록 하기 위해 인터럽트 발생 시 저장되어야 한다.
* CPU 스케줄링 정보 - 이 정보는 프로세스 우선순위, 스케줄 큐에 대한 포인터와 다른 스케줄 매개변수를 포함한다.
* 메모리 관리 정보 - 이 정보는 운영체제에 의해 사용되는 메모리 시스템에 따라 베이스, 리미트 레지스터의 값. 운영체제가 사용하는 메모리 시스템에 따라 페이지, 세그먼트 테이블 등과 같은 정보를 포함한다.
* 회계 정보 - 이 정보는 CPU 사용 시간과 경과된 실시간, 시간 제한, 계정 정보, 잡 또는 프로세스 번호 등을 포함한다.
* 입출력 상태 정보 - 이 정보는 이 프로세스에 할당된 입출력 장치들과 열린 파일의 목록 등을 포함한다.

**결론은 PCB는 약간의 회계 데이터와 함께 프로세스를 시작시키거나 다시 시작시키는 데 필요한 모든 데이터를 위한 저장소 역활을 한다.**

이미지는 아래와 같다.<br/>

![imageProcess]({{ site.url }}{{ site.baseurl }}/assets/images/posts/image_os_pcb.png)

## 스레드

앞에서 얘기한 프로세스는 단일 실행 스레드를 실행하는 프로그램임을 의미한다. 예를 들면, 만일 한 프로세스가 워드 프로세서 프로그램을 실행 중이면, 실행되는 명령어의 단일 스레드가 존재한다. 이 단일 제어 스레드는 프로세스가 한 번에 한가지 일만 처리할 수 있도록 허용한다. 따라서 사용자는 문자를 입력하면서 동시에 철자 검사기를 실행할 수 없다.

> 대부분의 현대 운영체제는 프로세스 개념을 확장하여 한 프로세스가 다수의 실행 스레드를 가질 수 있도록 허용한다. 따라서 프로세스가 한 번에 하나 이상의 일을 수행할 수 있도록 허용한다. 이러한 특성은 특히 멀티 코어 프로세서에서 이익을 얻을 수 있는데, 여러 스레드가 병렬로 실행될 수 있다.

## 프로세스 스케줄링

다중 프로그래밍의 목적은 CPU를 최대한 사용하기 위해 항상 어떤 프로세스가 실행 되도록 하는 데 있다. 시분할의 목적은 각 프로그램이 실행되는 동안 사용자가 상호 작용할 수 있도록 여러개의 프로세스 사이에서 CPU 코어를 빈번하게 교체하는 것이다. 이를 위해 프로세스 스케줄러는 코어에서 실행 가능한 여러 프로세스 중에서 하나의 프로세스를 선택한다. 각 CPU 코어는 한 번에 하나의 프로세스만 실행할 수 있다. 단일 CPU 코어 시스템의 경우 한 번에 2개 이상의 프로세스가 실행될 수 없지만 다중 코어 시스템은 한 번에 여러 프로세스를 실행할 수 있다. 코어보다 많은 프로세스가 있는 경우 초과 프로세스는 코어가 사용 가능해지고 다시 스케줄 될 때까지 기다려야 한다. 현재 메모리에 있는 프로세스 수를 **다중 프로그래밍 정도**라고 한다. 다중 프로그래밍 및 시간 공유의 목표를 균형 있게 유지하려면 프로세스의 일반적인 동작을 고려해야 한다. 일반적으로 대부분의 프로세스는 IO 바운드 또는 CPU 바운드로 설명할 수 있다.

IO 바운드 프로세스 - 계산에 소비하는 것보다 IO에 더 많은 시간을 소비하는 프로세스이다.
CPU 바운드 프로세스 - 계산에 더 많은 시간을 사용하여 IO 요청을 자주 생성하지 않는다.

### 스케줄링 큐

프로세스가 시스템에 들어가면 준비 큐에 들어가서 준비 상태가 되어 CPU 코어에서 실행되기를 기다린다. 이 큐는 일반적으로 연결 리스트로 저장된다. 준비 큐 헤더에는 리스트의 첫 번째 PCB에 대한 포인터가 저장되고 각 PCB에는 준비 큐의 다음 PCB를 가리키는 포인터 필드가 존재한다.

시스템에는 다른 큐도 존재한다. 프로세스에 CPU 코어가 할당되면 프로세스는 잠시 동안 실행되어 결국 종료되거나 인터럽트 되거나 IO요청의 완료와 같은 특정 이벤트가 발생할 때까지 기다린다. 프로세스가 디스크와 같은 장치에 IO 요청을 한다고 가정하자. 장치는 프로세서보다 상당히 느리게 실행되므로 프로세스는 IO가 사용 가능할 때까지 기다려야 한다. IO 완료와 같은 특정 이벤트가 발생하기를 기다리는 프로세스는 대기 큐에 삽입된다.

![imageProcess]({{ site.url }}{{ site.baseurl }}/assets/images/posts/image_os_ready_queue_wait_queue.jpg)

프로세스 스케줄링의 일반적인 표현은 아래의 그림과 같은 큐잉 다이어그램이다. 준비 큐와 대기 큐의 집합의 두 가지 유형의 큐가 있다. 원은 큐에 서비스를 제공하는 **자원**을 나타내고 화살표는 시스템의 프로세스의 흐름을 나타낸다. 새 프로세스는 처음에 준비 큐에 놓인다. 프로세스는 실행을 위해 선택되거나 또는 디스패치 될 때까지 기다린다. 프로세스에 CPU 코어가 할당되고 실행 상태가 되면, 여러 이벤트 중 하나가 발생할 수 있다.

* 프로세스가 IO 요청한 다음 IO 대기 큐에 놓일 수 있다.
* 프로세스는 새 자식 프로세스를 만든 다음 자식의 종료를 기다리는 동안 대기 큐에 놓일 수 있다.
* 인터럽트 또는 타임 슬라이스가 만료되어 프로세스가 코어에서 강제로 제거되어 준비 큐로 돌아갈 수 있다.

> 처음 두 경우에는 프로세스가 결국 대기 상태에서 준비 상태로 전환된 다음 준비 큐에 다시 들어간다. 프로세스는 종료될 때까지 이 주기를 계속한다. 종료 시점에 모든 큐에서 제거되고 PCB 및 자원이 반환된다.

![imageProcess]({{ site.url }}{{ site.baseurl }}/assets/images/posts/image_os_wait_for_process_schedule.png)


### CPU 스케줄링

프로세스는 수명주기 동안 준비 큐와 다양한 대기 큐를 이주한다. CPU 스케줄러의 역할은 준비 큐에 있는 프로세스 중에서 선택된 하나의 프로세스에 CPU 프로세서를 할당한다. CPU 스케줄러는 CPU를 할당하기 위한 새 프로세스를 자주 선택해야 한다. IO 바운드 프로세스는 IO 요청을 대기하기 전에 몇 밀리초 동안만 실행할 수 있다. CPU 바운드 프로세스에는 오랜 시간 동안 CPU 코어가 필요하지만 스케줄러는 프로세스에게 코어를 장기간 부여할 가능성이 없다. 대신 프로세스에서 CPU를 강제로 제거하고 실행될 다른 프로세스를 스케줄 하도록 설계될 가능성이 높다. 따라서 CPU 스케줄러는 일반적으로 훨씬 더 자주 실행되지만 적어도 100밀리초마다 한 번씩 실행된다.

> 일부 운영체제는 스와핑이라고 알려진 중간 형태의 스케줄링을 가지고 있는데, 핵심 아이디어는 **때떄로 메모리에서 프로세스를 제거하여 다중 프로그래밍 정도를 감소시키는 것이 유리할 수 있다는 것이다.** 나중에 프로세스를 메모리에 다시 적재할 수 있으며 중단된 위치에서 실행을 계속할 수 있다. 프로세스를 메모리에서 디스크로 __스왑아웃__ 하여 현재 상태를 저장하고, 이후 디스크에서 메모리로 __스왑인__ 하여 상태를 복원할 수 있기 때문이 기 법을 스와핑이라고 한다. 

>> 스와핑은 일반적으로 메모리가 초과 사용되어 가용공간을 확보해야 할 때만 필요하다.

### 문맥 교환

> 인터럽트는 운영체제가 CPU 코어를 현재 작업을 중단시키고 새로운 커널 루틴 작업을 실행할 수 있게 한다.

인터럽트는 범용 시스템에서 자주 발생한다. 인터럽트가 발생하면 시스템은 인터럽트 처리가 끝난 후에 문맥을 복구할 수 있도록 현재 실행 중인 프로세스의 문맥을 저장할 필요가 있다. 

* 인터럽트는 결국 프로세스를 중단했다가 재개하는 작업이다.

문맥은 프로세스의 PCB에 표현된다. 문맥은 CPU 레지스터의 값, 프로세스의 상태, 메모리 관리 정보 등을 포함한다. 일반적으로 커널 모드이건 사용자 모드이건 CPU의 현재 상태를 저장하는 작업을 수행하고, 나중에 연산을 재개하기 위해 상태 복구 작업을 수행한다.

> CPU 코어를 다른 프로세스로 교환하려면 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 보관된 상태를 복구하는 작업이 필요한데, 이 작업을 문맥 교환이라고 한다. 

문맥 교환이 일어나면, 커널은 과거 프로세스의 문맥을 PCB에 저장하고, 스케줄된 새로운 프로세스의 저장된 문맥을 복구한다. 문맥 교환이 진행될 동안 시스템이 아무런 유용한 일을 못 하기 때문에 문맥 교환 시간은 순수한 오버헤드이다. 교환 속도는 메모리의 속도, 반드시 복사되어야 하는 레지스터의 수, 특수 명령어의 존재에 좌우되므로, 기계마다 다르다. 문맥 교환 시간은 하드웨어의 지원에 크게 좌우된다. 예를 들어, 일부 처리기들은 여러 개의 레지스터 집합을 제공한다. 문맥 교환은 단순히 현행 레지스터 집합에 대한 포인터를 변경하는 것을 포함한다. 물론, 레지스터 집합들보다도 활성 프로세스들이 더 많다면, 시스템은 전처럼 레지스터 자료를 메모리로 또는 메모리에서 복사해야 한다. 또한 운영체제가 복잡할수록, 문맥 교환 시 해야 할 작업의 양이 더 많아진다. 

* 고급 메모리 관리 기법을 사용하면 문맥 교환 시 더 많은 자료들을 교환해야 한다.

![imageProcess]({{ site.url }}{{ site.baseurl }}/assets/images/posts/image_os_context_change.png)