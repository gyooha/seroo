<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-03-17T00:48:17+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Seroo’s Blog</title><subtitle></subtitle><author><name>{&quot;name&quot;=&gt;nil, &quot;avatar&quot;=&gt;nil, &quot;bio&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;links&quot;=&gt;[{&quot;label&quot;=&gt;&quot;Email&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-envelope-square&quot;}, {&quot;label&quot;=&gt;&quot;Website&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-link&quot;}, {&quot;label&quot;=&gt;&quot;Twitter&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-twitter-square&quot;}, {&quot;label&quot;=&gt;&quot;Facebook&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-facebook-square&quot;}, {&quot;label&quot;=&gt;&quot;GitHub&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-github&quot;}, {&quot;label&quot;=&gt;&quot;Instagram&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-instagram&quot;}]}</name></author><entry><title type="html">CleanArchitecture - SOLID Principles</title><link href="http://localhost:4000/cleanarchitecture/solid" rel="alternate" type="text/html" title="CleanArchitecture - SOLID Principles" /><published>2020-03-13T00:00:00+09:00</published><updated>2020-03-13T00:00:00+09:00</updated><id>http://localhost:4000/cleanarchitecture/clean-architecture-solid</id><content type="html" xml:base="http://localhost:4000/cleanarchitecture/solid">&lt;h1 id=&quot;solid&quot;&gt;SOLID&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html&quot;&gt;클린아키텍처&lt;/a&gt;라는 블로그와 책을 읽고 여러 파트에 나뉘어 정리해볼려고 한다. 첫 파트는 SOLID 이다.&lt;/p&gt;

&lt;h2 id=&quot;단일-책임-원칙srp-single-responsibility-principle&quot;&gt;단일 책임 원칙(SRP, Single Responsibility Principle)&lt;/h2&gt;

&lt;p&gt;한개의 모듈은 하나의 액터에 대해서만 책임 져야 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;여기서 &lt;em&gt;모듈&lt;/em&gt; 이란 단어의 가장 단순한 정의는 &lt;strong&gt;소스 파일&lt;/strong&gt;을 의미한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;예제&quot;&gt;예제&lt;/h3&gt;

&lt;p&gt;급여 앱의 Employee 클래는 SRP를 위반한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/posts/image_SRP_01.png&quot; alt=&quot;imageSRP&quot; /&gt;&lt;/p&gt;

&lt;p&gt;왜냐하면 위의 세 가지 메소드는 서로 매우 다른 세명의 액터를 책임지기 때문이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;caculatePay() 메소드는 회계팀에서 기능을 정의하며, CFO 보고를 위해 사용한다.&lt;/li&gt;
  &lt;li&gt;reportHours() 메소드는 인사팀에서 기능을 정의하고 사용하며, COO 보고를 위해 사용한다.&lt;/li&gt;
  &lt;li&gt;save() 메소드는 데이터베이스 관리자가 기능을 정의하고, CTO 보고를 위해 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;개발자가 세 메소드를 Employee라는 단일 클래스에 배치하여 세 액터가 서로 결합되어 버렸다. 이 결합으로 인해 CFO 팀에서 결정한 조치가 COO 팀이 의존하는 무언가에 영향을 줄 수 있다. 예를 들어 calculatePay() 메소드와 reportHours() 메소드가 초과 근무를 제외한 업무 시간을 계산하는 알고리즘을 공유한다고 해보자. 그리고 개발자는 코드 중복을 피하기 위해 이 알고리즘을 regularHours()라는 메소드에 넣었다고 해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/posts/image_SRP_02.png&quot; alt=&quot;imageSRP&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 CFO 팀에서 초과 근무를 제외한 업무 시간을 계산하는 방식을 약간 수정하기로 결정했다고 하자. 반면 인사를 담당하는 COO 팀에서 초과 근무를 제외한 업무 시간을 CFO 팀과는 다른 목적으로 사용하기 때문에, 이 같은 변경을 원하지 않는다고 해보자.&lt;/p&gt;

&lt;p&gt;이 변경을 적용하는 업무를 할당받은 개발자는 calculatePay() 메소드가 regularHours()를 호출한다는 사실을 발견하지만, 이 함수가 reportHours() 메소드에서도 호출된다는 사실은 눈치채지 못한다. 개발자는 요청된 변경사항을 적용하고 신중하게 테스트한다. CFO 팀은 새로운 메소드가 원하는 방식으로 동작하는 검증하고, 시스템은 배포된다. 물론 COO 팀에서는 이러한 일이 벌어지고 있다는 사실은 인지하지 못한다. COO 팀 직원은 reportHours() 메소드가 생성한 보고서를 여전히 이용한다. 하지만 이제 이 보고서에 포함된 수치들은 엉터리다. 마침내 문제가 발견되고, COO는 격노한다. 잘못된 데이터로 인해 수백만 달러의 예산이 지출되었기 때문이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;서로 다른 액터가 의존하는 코드를 너무 가까이 배치하면 위와 같은 문제가 발생한다. SRP는 서로 다른 액터가 의존하는 코드를 분리하라고 말한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;결론&quot;&gt;결론&lt;/h3&gt;

&lt;p&gt;단일 책임 원칙은 &lt;strong&gt;메소드와 클래스 수준&lt;/strong&gt;의 원칙이다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;컴포넌트 수준에서는 공통 폐쇄 원칙이 된다.&lt;/li&gt;
    &lt;li&gt;아키텍처 수준에서는 아키텍처의 경계의 생성을 책임지는 변경의 축이 된다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;개방-폐쇄-원칙ocp-opne-close-principle&quot;&gt;개방 폐쇄 원칙(OCP, Opne-Close Principle)&lt;/h2&gt;

&lt;p&gt;확장에는 열려있어야 하고, 변경에는 닫혀 있어야 한다.&lt;/p&gt;

&lt;h3 id=&quot;예제-1&quot;&gt;예제&lt;/h3&gt;

&lt;p&gt;재무재표를 웹 페이지로 보여주는 시스템이 있다고 생각해보자. 웹 페이지에 표시되는 데이터는 스크롤할 수 있으며, 음수는 빨간색으로 출력한다.&lt;/p&gt;

&lt;p&gt;이제 이해관계자가 동일한 정보를 보고서 형태로 변환해서 흑백 프린터로 출력해 달라고 요청했다고 해보자. 이 보고서에는 페이지 번호가 제대로 매겨져 있어야 하고, 페이지마다 적절한 머리글과 바닥글이 있어야 하며, 표의 각 열에는 레이블이 있어야 한다고 해보자. 또한 음수는 괄호로 감싸야 한다. 당연히 새로운 코드를 작성해야 한다. 그렇다면 얼마나 많이 수정해야 할까?&lt;/p&gt;

&lt;p&gt;이상적인 변경량은 &lt;em&gt;0&lt;/em&gt; 으로 보고, 소프트웨어 아키텍처가 훌륭하다면 변경되는 코드의 양이 가능한 한 최소화될 것이다.&lt;/p&gt;

&lt;p&gt;어떻게 하면 될까? 서로 다른 목적으로 변경되는 요소를 적절하게 분리하고(단일 책임 원칙 SRP), 이들 요소 사이의 의존성을 체계화함으로써(의존성 역전 원칙 DIP) 변경량을 최소화할 수 있다.&lt;/p&gt;

&lt;p&gt;단일 책임 원칙을 적용하면 데이터 흐름을 아래의 그림과 같은 형태로 만들 수 있다. 재무 데이터를 검사한 후 보고서용 데이터를 생성한 다음, 필요에 따라 두 가지 보고서 생성 절차 중 하나를 거쳐 적절히 포매팅 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/posts/image_OCP_01.png&quot; alt=&quot;imageOCP&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기서 얻을 수 있는 가장 중요한건 생성이 두 개의 책임으로 분리된다는 사실이다. 하나는 보고서용 데이터를 계산하는 책임이며, 하나는 이 데이터를 웹으로 보여주거나, 종이로 프린트하기에 적합한 형태로 표현하는 책임이다.&lt;/p&gt;

&lt;p&gt;이처럼 책임을 분리했다면, 두 책임 중 하나에서 변경이 발생하더라도 다른 하나는 변경되지 않도록 소스 코드 의존성도 확실히 조직화해야 한다. 또한, 새로 조직화한 구조에서는 행위가 확장될 때 변경이 발생하지 않음을 보장한다.&lt;/p&gt;

&lt;p&gt;이러한 목적을 달성하려면 처리 과정을 클래스 단위로 분할하고, 이들 클래스를 아래 그림과 같이 컴포넌트 단위로 구분해야 한다. 이 그림에서 좌측 상단의 컴포넌트는 Controller 이고, 우측 상단은 Interactor 컴포넌트, 우측 하단은 Database 컴포넌트 이다. 좌측 하단에는 View와 Presenter를 담당하는 네 가지 컴포넌트가 위치한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/posts/image_OCP_02.png&quot; alt=&quot;imageOCP&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&amp;lt;I&amp;gt; 로 표시된 클래스는 인터페이스이며, &amp;lt;DS&amp;gt;로 표시된 클래스는 데이터 구조다. 화살표가 열려 있다면 사용 관계이며, 닫혀 있다면 구현관계 또는 상속관계다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;여기에서 주목할 점은 모든 의존성이 소스 코드 의존성을 나타낸다는 사실이다. 예를 들어 화살표가 A 클래스에서 B 클래스로 향한다면, A 클래스 에서는 B 클래스를 호출하지만 B 클래스에서는 A 클래스를 전혀 호출하지 않음을 뜻한다. 따라서 &lt;strong&gt;FinancialDataMapper&lt;/strong&gt;는 구현 관계를 통해 &lt;strong&gt;FinancialDataGateway&lt;/strong&gt;를 알지만, &lt;strong&gt;FinancialDataGateway&lt;/strong&gt;는 &lt;strong&gt;FinancialDataMapper&lt;/strong&gt;에 대해 알지 못한다.&lt;/p&gt;

&lt;p&gt;여기서 또 주목해야할 점은 화살표가 오직 한 방향으로만 교차한다는 것이다. 이는 모든 컴포넌트 관계는 단방향으로만 이루어진다는 뜻이다. 이들 화살표는 변경으로부터 보호하려는 컴포넌트를 향하도록 그려진다.&lt;/p&gt;

&lt;p&gt;다시 말하지만, A 컴포넌트에서 발생한 변경으로부터 B 컴포넌트를 보호하려면 반드시 A 컴포넌트가 B 컴포넌트에 의존해야 한다. 이 예제의 경우 Presenter에서 발생한 변경으로부터 Controller를 보호하고자 한다. 그리고 View에서 발생한 변경으로부터 Presenter를 보호하고자 한다. Interactor는 다른 모든 것에서 발생한 변경으로부터 보호하고자 한다. Interactor는 OCP를 가장 잘 준수할 수 있는 곳에 위치한다. Database, Controller, Presenter, View에서 발생한 어떤 변경도 Interactor에 영향을 주지 않는다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;왜 Interactor가 특별한 위치를 차지해야만 하는가?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;답은 Interactor가 비즈니스 로직을 포함하기 때문이다. Interactor는 앱에서 가장 높은 수준의 정책을 포함한다. Interactor 이외의 컴포넌트는 모두 주변적인 문제를 처리한다. 가장 중요한 로직은 Interactor에서 담당한다. 마찬가지로 Presenter가 Controller보다는 부수적이더라도 View보다는 중심적인 문제를 처리한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;보호의 계층구조가 수준(level)이라는 개념을 바탕으로 어떻게 생성되는지 주목하자. Interactor는 가장 높은 수준의 개념이며, 따라서 최고의 보호를 받는다. View는 가장 낮은 수준의 개념 중 하나이며, 따라서 거의 보호를 받지 못한다. Presenter는 View 보다는 높고 Controller나 Interactor보다는 낮은 수준에 위치한다.&lt;/p&gt;

&lt;p&gt;이것이 바로 &lt;strong&gt;아키텍처 수준&lt;/strong&gt;에서 OCP가 동작하는 방식이다. 아키텍트는 기능이 어떻게 왜 언제 발생하는지에 따라 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화한다. 컴포넌트 계층구조를 이와 같이 조직화하면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;결론-1&quot;&gt;결론&lt;/h3&gt;

&lt;p&gt;OCP는 시스템 아키텍처를 떠받치는 원동력 중 하나다. OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 데 있다. 이러한 목표를 달성하려면 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야 한다.&lt;/p&gt;

&lt;h2 id=&quot;liskovs-substitution-principle&quot;&gt;Liskov’s Substitution Principle&lt;/h2&gt;

&lt;p&gt;S 타입의 객체에 각각 대응하는 T 타입을 이용해서 정의한 모든 프로그램 P 에서 T 타입의 자리에 S 타입으로 치환하더라도 P의 행위가 변하지 않는다면, S는 T의 하위 타입이다.&lt;/p&gt;

&lt;h2 id=&quot;interface-segregation-principle&quot;&gt;Interface Segregation Principle&lt;/h2&gt;

&lt;p&gt;인터페이스를 분리하여 필요한 기능에만 의존해야 한다.&lt;/p&gt;

&lt;h2 id=&quot;dependency-inversion-principle&quot;&gt;Dependency Inversion Principle&lt;/h2&gt;

&lt;p&gt;추상에 의존하며 구체에는 의존하지 않아야 한다.&lt;/p&gt;

&lt;h1 id=&quot;요약&quot;&gt;요약&lt;/h1&gt;

&lt;h2 id=&quot;단일-책임-원칙srp-single-responsibility-principle-1&quot;&gt;단일 책임 원칙(SRP, Single Responsibility Principle)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;한개의 모듈은 하나의 액터에 대해서만 책임 져야 한다.&lt;/li&gt;
  &lt;li&gt;SRP는 클래스와 메소드 수준의 원칙이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;개방-폐쇄-원칙ocp-opne-close-principle-1&quot;&gt;개방 폐쇄 원칙(OCP, Opne-Close Principle)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;확장에는 열려있어야 하고, 변경에는 닫혀 있어야 한다.&lt;/li&gt;
  &lt;li&gt;시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야한다.&lt;/li&gt;
  &lt;li&gt;컴포넌트를 보호하려면 변경이 발생하는 컴포넌트가 보호하려는 컴포넌트에 의존해야 한다.&lt;/li&gt;
  &lt;li&gt;OCP는 아키텍처 수준의 원칙이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;참조&quot;&gt;참조&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.yes24.com/Product/Goods/77283734&quot;&gt;클린아키텍처 책&lt;/a&gt;&lt;/p&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;avatar&quot;=&gt;nil, &quot;bio&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;links&quot;=&gt;[{&quot;label&quot;=&gt;&quot;Email&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-envelope-square&quot;}, {&quot;label&quot;=&gt;&quot;Website&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-link&quot;}, {&quot;label&quot;=&gt;&quot;Twitter&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-twitter-square&quot;}, {&quot;label&quot;=&gt;&quot;Facebook&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-facebook-square&quot;}, {&quot;label&quot;=&gt;&quot;GitHub&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-github&quot;}, {&quot;label&quot;=&gt;&quot;Instagram&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-instagram&quot;}]}</name></author><category term="CleanArchitecture" /><category term="SOLID" /><summary type="html">SOLID</summary></entry><entry><title type="html">Android OS history</title><link href="http://localhost:4000/android/os" rel="alternate" type="text/html" title="Android OS history" /><published>2020-03-11T00:00:00+09:00</published><updated>2020-03-11T00:00:00+09:00</updated><id>http://localhost:4000/android/android-os-history</id><content type="html" xml:base="http://localhost:4000/android/os">&lt;h1 id=&quot;android-os-히스토리&quot;&gt;Android OS 히스토리&lt;/h1&gt;

&lt;h2 id=&quot;킷캣-44&quot;&gt;킷캣 4.4&lt;/h2&gt;

&lt;p&gt;ART(Android RunTime) 시험적 추가&lt;/p&gt;

&lt;h2 id=&quot;롤리팝-50&quot;&gt;롤리팝 5.0&lt;/h2&gt;

&lt;p&gt;ART(Android RunTime) 정식 적용&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;AOT(Ahead-of-time) 컴파일&lt;/li&gt;
  &lt;li&gt;GC 개선&lt;/li&gt;
  &lt;li&gt;디버그 지원 개선&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;머티리얼 디자인 적용&lt;/p&gt;

&lt;p&gt;앱이 API 21 이상을 대상으로 하는 경우 MixedContents, ThirdPartyCookies를 기본적으로 차단 한다. (21 미만의 경우는 허용)&lt;/p&gt;

&lt;h2 id=&quot;마시멜로우-60&quot;&gt;마시멜로우 6.0&lt;/h2&gt;

&lt;p&gt;런타임 권한 적용&lt;/p&gt;

&lt;p&gt;Doze 모드, 앱 대기 모드 추가&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Doze 모드 - 충전상태가 아니고 화면이 꺼져있는 경우 앱은 Doze 모드로 진입 한다. 이 때 앱은 절전모드를 계속 유지하게 된다. 이 모드에서는 주기적으로 보류된 작업을 실행하여 앱 동기화 작업을 진행한다.&lt;/li&gt;
  &lt;li&gt;앱 대기 모드 - 시스템은 일정시간 사용자와 상호작용 없는 앱의 경우 idle 상태로 진입하게 된다. 디바이스가 충전중이 아닌 경우 네트워크 호출을 비활성화 하며, 앱이 idle 상태로 진입할 경우 동기화 작업을 중단한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Apache HTTP 클라이언트 제거&lt;/p&gt;

&lt;h2 id=&quot;누가-70&quot;&gt;누가 7.0&lt;/h2&gt;

&lt;p&gt;Doze 모드 강화 
백그라운드 최적화&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;CONNECTIVITY_ACTION, ACTION_NEW_PICTURE, ACTION_NEW_VIDEO 브로드캐스트를 더이상 수신할 수 없게 변경 되었다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;오레오-80&quot;&gt;오레오 8.0&lt;/h2&gt;

&lt;p&gt;백그라운드 제한
노티피케이션 채널 추가&lt;/p&gt;

&lt;h2 id=&quot;파이-90&quot;&gt;파이 9.0&lt;/h2&gt;

&lt;p&gt;백그라운드 앱 권한 제한&lt;/p&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;avatar&quot;=&gt;nil, &quot;bio&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;links&quot;=&gt;[{&quot;label&quot;=&gt;&quot;Email&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-envelope-square&quot;}, {&quot;label&quot;=&gt;&quot;Website&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-link&quot;}, {&quot;label&quot;=&gt;&quot;Twitter&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-twitter-square&quot;}, {&quot;label&quot;=&gt;&quot;Facebook&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-facebook-square&quot;}, {&quot;label&quot;=&gt;&quot;GitHub&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-github&quot;}, {&quot;label&quot;=&gt;&quot;Instagram&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-instagram&quot;}]}</name></author><category term="Android" /><category term="OS" /><summary type="html">Android OS 히스토리</summary></entry><entry><title type="html">Android Service - 1</title><link href="http://localhost:4000/android/service1" rel="alternate" type="text/html" title="Android Service - 1" /><published>2020-03-11T00:00:00+09:00</published><updated>2020-03-11T00:00:00+09:00</updated><id>http://localhost:4000/android/android-service01</id><content type="html" xml:base="http://localhost:4000/android/service1">&lt;h1 id=&quot;서비스&quot;&gt;서비스&lt;/h1&gt;
&lt;p&gt;UI가 없고 백그라운드에서 오래 연산해야 하는 작업을 실행할 때 사용하는 앱 컴포넌트 이다. 다른 앱 컴포넌트가 서비스를 실행할 수 있으며, 사용자가 다른 앱으로 이동해도 서비스는 계속해서 백그라운드에서 동작한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;서비스는 컴포넌트에 바인드되어 상호작용 할 수 있으며,  IPC를 이용하여 프로세스간 통신을 할 수 있다.
서비스는 아래와 같은 상황에 종종 사용한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;네트워크 호출&lt;/li&gt;
  &lt;li&gt;음악 재생&lt;/li&gt;
  &lt;li&gt;파일 I/O&lt;/li&gt;
  &lt;li&gt;컨텐트 프로바이더와 상호작용&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;서비스는 백그라운드에서 실행된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;서비스-종류&quot;&gt;서비스 종류&lt;/h2&gt;

&lt;h3 id=&quot;포그라운드foreground&quot;&gt;포그라운드(Foreground)&lt;/h3&gt;

&lt;p&gt;포그라운드 서비스는 음악 앱에서 음악 재생을 사용자에게 알려주는 것과 같이 &lt;em&gt;서비스가 작업중일 때 사용자에게 알려준다.&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;포그라운드 서비스는 반드시 노티피케이션을 표시해야 하며, 사용자가 앱과 상호작용이 없더라도 계속해서 실행된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;백그라운드background&quot;&gt;백그라운드(Background)&lt;/h3&gt;

&lt;p&gt;백그라운드 서비스는 사용자 알지 못하는 작업을 수행한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;안드로이드 26 부터 백그라운드 서비스에 대한 제약이 강화됐다. 백그라운드에서 사용자의 위치 정보를 접근할 수 없으며, 백그라운드 서비스는 약간의 시간(약 5초)이 지나면 시스템에 의해 강제종료 된다. 대체제로 워크매니저를 사용!!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;바운드bound&quot;&gt;바운드(Bound)&lt;/h3&gt;

&lt;p&gt;바운드 서비스는 앱의 컴포넌트에 바인드된 서비스를 의미한다. 바운드 서비스는 클라이언트-서버 인터페이스를 제공하며, 바인딩된 컴포넌트와 서비스는 &lt;em&gt;전송요청&lt;/em&gt;, &lt;em&gt;응답결과받기&lt;/em&gt;, &lt;em&gt;IPC를 이용한 프로세스간 통신&lt;/em&gt; 등의 액션을 취할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;바운드 서비스는 다른 앱의 컴포넌트가 바운드된 경우에만 실행되고, 여러 컴포넌트를 바인드할 수 있다. 하지만 바인드 된 컴포넌트가 없는경우 서비스는 종료된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;서비스에서-스레드-선택&quot;&gt;서비스에서 스레드 선택&lt;/h2&gt;

&lt;p&gt;서비스는 백그라운드 작업이지만 기본적으로 &lt;em&gt;메인스레드&lt;/em&gt; 에서 실행된다. 그러므로 서비스에서 오래 걸리는 작업을 수행할 경우 &lt;strong&gt;스레드 전환&lt;/strong&gt;이 필요하다. Thread 클래스를 이용하여 스레드 전환을 하는 경우 아래와 같이 작업하면 된다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;em&gt;onCreate()&lt;/em&gt; 콜백에서 스레드를 생성&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;onStart()&lt;/em&gt; 콜백에서 스레드 실행&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;onStop()&lt;/em&gt; 콜백에서 스레드 정지&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;그 외에도 RxJava나 Corotuine을 이용하여 스레드 전환을 시도하는 경우 각 콜백에 맞게 작업을 진행하면 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;서비스-콜백-메소드&quot;&gt;서비스 콜백 메소드&lt;/h2&gt;

&lt;h3 id=&quot;onstartcommand&quot;&gt;onStartCommand()&lt;/h3&gt;

&lt;p&gt;다른 컴포넌트에서 &lt;em&gt;startService()&lt;/em&gt; 메소드를 호출하면 시스템은 이 콜백을 호출한다. &lt;em&gt;stopSelf()&lt;/em&gt;, &lt;em&gt;stopService()&lt;/em&gt; 같은 정지 메소드가 실행되지 않는한 무한정 실행되며 꼭 명시적으로 서비스를 정지시켜야 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;바운드 서비스로 실행된 경우 이 콜백을 구현하지 않아도 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;onbind&quot;&gt;onBind()&lt;/h3&gt;

&lt;p&gt;다른 컴포넌트에서 &lt;em&gt;bindService()&lt;/em&gt; 메소드를 호출하면 시스템은 (RPC를 실행하듯이) 해당 컴포넌트에 서비스를 바인드 한다. 이 메소드를 구현할 때 클라이언트가 IBinder를 리턴하여 서비스와 통신하는데 사용하는 인터페이스를 제공한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;서비스를 구현할 때 반드시 구현해야 하는 메소드이며, &lt;strong&gt;바인드 서비스가 아닌 경우&lt;/strong&gt; null을 리턴해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;oncreate&quot;&gt;onCreate()&lt;/h3&gt;

&lt;p&gt;서비스가 생성되고 초기화 될 때 시스템은 &lt;em&gt;onCreate()&lt;/em&gt; 콜백을 호출한다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;이 콜백은 &lt;em&gt;onStartCommand()&lt;/em&gt; 와 &lt;em&gt;onBind()&lt;/em&gt; 콜백 전에 호출되며, 서비스가 이미 실행중인 경우 호출되지 않는다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;### onDestroy()&lt;/p&gt;

&lt;p&gt;서비스가 더이상 사용되지 않고, 종료 프로세스를 진행중에 시스템이 호출하는 콜백이다. Activity와 유사하게 사용하는 리소스를 전부 이 콜백에서 해제 시켜줘야 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;서비스의 가장 마지막에 호출되는 콜백이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;서비스가 다른 컴포넌트에서 &lt;em&gt;startService()&lt;/em&gt; 로 실행된 경우 서비스 스스로 &lt;em&gt;stopSelf()&lt;/em&gt; 메소드를 호출하거나, 서비스를 호출한 컴포넌트에서 &lt;em&gt;stopService()&lt;/em&gt; 메소드를 호출하지 않으면 계속 실행된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;백그라운드 서비스의 경우 제약이 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;서비스가 다른 컴포넌트에서  &lt;em&gt;bindService&lt;/em&gt; 로 실행된 경우 &lt;em&gt;onStartCommand()&lt;/em&gt; 는 실행되지 않으며 컴포넌트에 바인드 되어 있는 동안 실행된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;바인드된 컴포넌트가 없으면 시스템에 의해 서비스는 종료된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;포그라운드 Activity를 표시하기 위해 시스템 리소스가 필요한 경우 서비스는 &lt;strong&gt;시스템에 의해 종료&lt;/strong&gt; 될 수 있다. 서비스가 포그라운드 Activity에 바인드 되어 있거나, 포그라운드 서비스로 실행되는 경우 드물게 강제종료 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;백그라운드 서비스의 경우 위에서 자주 언급했듯이 5초~10초 사이로 강제종료 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;서비스는 Manifest 파일에 반드시 명시해줘야 하며 명시적 인텐트를 이용하여 서비스를 실행해야 하고, 인텐트 필터를 작성하면 안된다. 안드로이드 API 21 부터  암시적 인텐트로 &lt;em&gt;bindService()&lt;/em&gt; 를 실행하는 경우 예외가 발생한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;서비스-onstartcommand-리턴-값-구분&quot;&gt;서비스 onStartCommand 리턴 값 구분&lt;/h2&gt;

&lt;p&gt;시스템이 서비스를 강제종료 하는 경우, 리소스를 다시 서비스에 할당할 수 있게 되면 서비스가 다시 시작될 수 있다. 이 때 &lt;em&gt;onStartCommand()&lt;/em&gt; 에서 반환하는 값에 따라 달라진다. 그러므로 서비스는 재시작 처리를 정상적으로 할 수 있도록 설계해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;start_sticky&quot;&gt;START_STICKY&lt;/h3&gt;

&lt;p&gt;대부분의 경우에 사용되며, 서비스가 종료되고 나서 시작될 때 인텐트는 null로 전달된다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;대부분 여기서 intent null 처리를 하지 않아서 죽는 경우가 발생한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;start_not_sticky&quot;&gt;START_NOT_STICKY&lt;/h3&gt;

&lt;p&gt;서비스가 죽어도 다시 시작되지 않는다. 주로 배치작업 같은 주기적으로 체크하거나 작업이 실행중일 때 서비스가 종료되도 괜찮은 경우에 사용된다.&lt;/p&gt;

&lt;h3 id=&quot;start_redeliver_intent&quot;&gt;START_REDELIVER_INTENT&lt;/h3&gt;

&lt;p&gt;서비스가 다시 시작될 때 이전에 전달받았던 인텐트를 다시 전달한다. 서비스가 중간에 멈추더라도 처음에 실행했던 작업을 무조건 다시 시작해서 완료해야 하는 경우에 사용한다.&lt;/p&gt;

&lt;h2 id=&quot;참조&quot;&gt;참조&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.android.com/guide/components/services#Declaring&quot;&gt;도큐먼트&lt;/a&gt;&lt;/p&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;avatar&quot;=&gt;nil, &quot;bio&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;links&quot;=&gt;[{&quot;label&quot;=&gt;&quot;Email&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-envelope-square&quot;}, {&quot;label&quot;=&gt;&quot;Website&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-link&quot;}, {&quot;label&quot;=&gt;&quot;Twitter&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-twitter-square&quot;}, {&quot;label&quot;=&gt;&quot;Facebook&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-facebook-square&quot;}, {&quot;label&quot;=&gt;&quot;GitHub&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-github&quot;}, {&quot;label&quot;=&gt;&quot;Instagram&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-instagram&quot;}]}</name></author><category term="Android" /><category term="Service" /><summary type="html">서비스 UI가 없고 백그라운드에서 오래 연산해야 하는 작업을 실행할 때 사용하는 앱 컴포넌트 이다. 다른 앱 컴포넌트가 서비스를 실행할 수 있으며, 사용자가 다른 앱으로 이동해도 서비스는 계속해서 백그라운드에서 동작한다.</summary></entry><entry><title type="html">Android Activity - Summary</title><link href="http://localhost:4000/android/activity-summary" rel="alternate" type="text/html" title="Android Activity - Summary" /><published>2020-03-10T00:00:00+09:00</published><updated>2020-03-10T00:00:00+09:00</updated><id>http://localhost:4000/android/android-activity-summary</id><content type="html" xml:base="http://localhost:4000/android/activity-summary">&lt;h2 id=&quot;activity&quot;&gt;Activity&lt;/h2&gt;

&lt;p&gt;안드로이드의 Activity는 한 앱이 다른 앱을 호출할 때 호출 앱은 다른 앱을 전체적으로 호출하는 것이 아니라 &lt;em&gt;다른 앱의 Activity를&lt;/em&gt; 호출한다. Activity는 이러한 패러다임으로 설계되었으며, 앱과 사용자의 상호작용을 담당한다.&lt;/p&gt;

&lt;h2 id=&quot;activity-라이프사이클activity-lifecycle&quot;&gt;Activity 라이프사이클(Activity Lifecycle)&lt;/h2&gt;

&lt;p&gt;안드로이드 Activity는 아래와 같은 라이프사이클을 가지고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;onCreate - Activity가 생성될 때 대부분 한번만 호출되는 콜백이다. 초기 셋팅은 물론 &lt;em&gt;setContentView()&lt;/em&gt; 를 이용한 레이아웃 정의도 이곳에서 진행된다.&lt;/li&gt;
  &lt;li&gt;onStart - Activity가 &lt;em&gt;시작상태&lt;/em&gt; 로 전환되어 사용자에게 표시 된다.&lt;/li&gt;
  &lt;li&gt;onResume - Activity가 사용자와 상호작용을 시작하기 직전에 호출된다.&lt;/li&gt;
  &lt;li&gt;onPause - Activity가 포커스를 잃고 &lt;em&gt;일시중지상태&lt;/em&gt; 로 전환될 때 호출되는 콜백이다. Activity가 사용자에게 여전히 표시되지만 대체로 사용자가 떠나는 중이며 있으며 조만간 &lt;em&gt;중지상태&lt;/em&gt;, &lt;em&gt;재개상태&lt;/em&gt; 상태로 전환됨을 의미한다.
    &lt;blockquote&gt;
      &lt;p&gt;onPause 콜백에서는 네트워크 호출, 데이터베이스 트랜잭션 실행을 하면 안된다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;onStop - 사용자에게 Activity가 더이상 표시되지 않을 때 나타나는 콜백이다. 이 때 Activity는 제거 중이거나, 새로운 Activity가 시작 중이거나, 기존 Activity가 &lt;em&gt;재개상태&lt;/em&gt; 로 전환임을 의미한다.&lt;/li&gt;
  &lt;li&gt;onRestart - &lt;em&gt;중지상태&lt;/em&gt; 의 Activity가 다시 시작되려고 할 때 이 콜백이 호출된다.&lt;/li&gt;
  &lt;li&gt;onDestroy - Activity가 제거되기 전에 이 콜백이 호출된다. 이 콜백에서는 Activity에서 사용하는 모든 리소스를 해제해야 한다.
    &lt;blockquote&gt;
      &lt;p&gt;시스템이 메모리 공간을 필요하게 되면 프로세스의 우선순위에 따라 프로세스가 종료된다. 그렇기 때문에 &lt;em&gt;onDestroy&lt;/em&gt; 콜백이 호출되지 않을 수 있다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위와 같은 Activity 라이프사이클을 적절하게 구현해야 아래와 같은 문제를 방지할 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;사용자가 앱을 사용하는 도중에 전화가 걸려오거나 다른 앱으로 전환할 때 비정상 종료됩니다.&lt;/li&gt;
  &lt;li&gt;사용자가 앱을 활발하게 사용하지 않는 경우, 소중한 시스템 리소스가 소비됩니다.&lt;/li&gt;
  &lt;li&gt;사용자가 앱에서 나갔다가 나중에 돌아왔을 때 사용자의 진행 상태가 손실됩니다.&lt;/li&gt;
  &lt;li&gt;화면이 가로 방향과 세로 방향 간에 회전할 경우, 비정상 종료되거나 사용자의 진행 상태가 손실됩니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;더 자세한 내용은 &lt;a href=&quot;https://developer.android.com/guide/components/activities/activity-lifecycle&quot;&gt;도큐먼트&lt;/a&gt;를 참조하자.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;activity와-메모리activity-and-memory&quot;&gt;Activity와 메모리(Activity and Memory)&lt;/h2&gt;

&lt;p&gt;시스템은 메모리가 필요할 때 프로세스를 종료한다. 시스템이 특정 프로세스의 상태에 따라 종료 우선순위가 결정되며 그리고 프로세스 상태는 Activity의 상태에 따라 달라진다. 아래의 표는 시스템이 프로세스를 종료할 가능성 사이에 상관관계를 나타낸다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;강제종료될 가능성&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;프로세스 상태&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Activity 상태&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;최소&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;포그라운드&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Created&lt;br /&gt;Started &lt;br /&gt; resumed&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;높음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;백그라운드(포커스 상실)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Paused&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;최대&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;백그라운드(보이지 않음)&lt;br /&gt;비어 있음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Stoped&lt;br /&gt;Destroyed&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;시스템은 메모리 공간을 확보하기 위해 절대 Activity를 직접 종료하지 않는다. 그 대신 Activity를 실행하는 프로세스를 종료하여 Activity뿐만 아니라 프로세스에서 실행되는 다른 모든 작업을 함께 종료한다.&lt;/p&gt;

&lt;h2 id=&quot;인스턴스-상태instance-state&quot;&gt;인스턴스 상태(Instance State)&lt;/h2&gt;

&lt;p&gt;Activity가 시스템 제약으로 인해 종료될 경우, 실제 Activity 인스턴스는 사라지더라도 시스템에 존재했다는 정보는 남아있는다. 사용자가 다시 Activity로 돌아가려고 시도하는 경우 시스템은 Activity의 상태를 나타내는 저장된 데이터 셋을 사용하여 해당 Activity의 새로운 인스턴스를 생성하는데 &lt;em&gt;시스템이 이전 상태를 복원하기 위해 사용하는 저장된 데이터를 인스턴스 상태&lt;/em&gt; 라고 한다.&lt;/p&gt;

&lt;h2 id=&quot;ui-상태-보존&quot;&gt;UI 상태 보존&lt;/h2&gt;

&lt;p&gt;사용자는 화면이 회전되거나 멀티 윈도우 모드로 전환되는 경우에도 UI의 상태가 그대로 유지되기를 기대한다. 그러나 안드로이드 에서 이러한 구성변경이 일어나면 &lt;em&gt;Activity를 종료시켜 Activity 인스턴스에 저장된 모든 UI 상태를 제거&lt;/em&gt; 한다. 이러한 경우 &lt;em&gt;onSaveInstanceState()&lt;/em&gt; 메소드와 &lt;em&gt;Android ViewModel&lt;/em&gt; 클래스 및 &lt;em&gt;Room&lt;/em&gt; 같은 로컬 데이터베이스를 사용하여 UI 상태를 임시로 보존해야 한다.&lt;/p&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;avatar&quot;=&gt;nil, &quot;bio&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;links&quot;=&gt;[{&quot;label&quot;=&gt;&quot;Email&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-envelope-square&quot;}, {&quot;label&quot;=&gt;&quot;Website&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-link&quot;}, {&quot;label&quot;=&gt;&quot;Twitter&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-twitter-square&quot;}, {&quot;label&quot;=&gt;&quot;Facebook&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-facebook-square&quot;}, {&quot;label&quot;=&gt;&quot;GitHub&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-github&quot;}, {&quot;label&quot;=&gt;&quot;Instagram&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-instagram&quot;}]}</name></author><category term="Android" /><category term="Activity" /><category term="Summary" /><summary type="html">Activity</summary></entry><entry><title type="html">Android Activity - 4</title><link href="http://localhost:4000/android/activity4" rel="alternate" type="text/html" title="Android Activity - 4" /><published>2020-03-02T00:00:00+09:00</published><updated>2020-03-04T00:00:00+09:00</updated><id>http://localhost:4000/android/android-activity-04</id><content type="html" xml:base="http://localhost:4000/android/activity4">&lt;h1 id=&quot;activity-상태변경state-change&quot;&gt;Activity 상태변경(State Change)&lt;/h1&gt;

&lt;p&gt;사용자 트리거, 시스템 트리거 이벤트는 Activity가 한 상태에서 다른 상태로 전환되는 원인이 될 수 있다. 그러한 전환이 발생하는 몇 가지 일반적인 사례와, 어떻게 처리할 수 있는지 살펴보자.&lt;/p&gt;

&lt;h2 id=&quot;activity-설정변경configuration-change&quot;&gt;Activity 설정변경(Configuration change)&lt;/h2&gt;

&lt;p&gt;설정변경 예제 중 가장 베스트 예제는 가로, 세로 변경일 것이다. 이 밖의 예제는 언어 변경이나, 입력 장치 삽입일 것이다. 앞의 포스트에서 보았듯이 설정변경이 일어나면 Activity는 파괴됐다가 재생성 된다. 기존의 Activity는 &lt;em&gt;onPause()&lt;/em&gt;, &lt;em&gt;onStop()&lt;/em&gt;, &lt;em&gt;onDestroy()&lt;/em&gt; 콜백이 순서대로 발생하며 종료되고, &lt;em&gt;onCreate()&lt;/em&gt;, &lt;em&gt;onStart()&lt;/em&gt;, &lt;em&gt;onResume()&lt;/em&gt; 콜백이 순서대로 발생하며 Activity의 새로운 인스턴스가 만들어진다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;안드로이드 ViewModel, onSaveInstanceState() 메소드와 Room 같은 local database를 같이 사용하면 설정변경에 영향받지 않고 Activity의 상태를 보호할 수 있다. 어떻게 앞의 컴포넌트를 결합할 것인지 결정하는 것은 UI 데이터의 복잡성, 앱의 사용 방법 및 검색 속도와 메모리 사용량 비교에 따라 결정된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;activity-foreground&quot;&gt;Activity Foreground&lt;/h2&gt;

&lt;p&gt;새로운 Activity가 foreground에 나타나게 되면 이전에 있던 Activity는 새로운 Activity에 &lt;strong&gt;부분적으로 가려지면&lt;/strong&gt; 포커스를 잃게 되면서 일시정지 상태로 들어가며 시스템은 &lt;em&gt;onPause()&lt;/em&gt; 콜백을 호출한다. 만약 이 상태에서 새로운 Activity가 종료되어 이전 Activity가 foreground에 나타나게 되면 &lt;em&gt;onResume()&lt;/em&gt; 콜백이 호출된다.&lt;/p&gt;

&lt;p&gt;새로운 Activity가 foreground에 나타나게 되면 이전에 있던 Activity는 새로운 Activity에 &lt;strong&gt;완전히 가려지면&lt;/strong&gt; 포커스를 잃게 되면서 정지 상태로 들어가며 시스템은 &lt;em&gt;onStop()&lt;/em&gt; 콜백을 호출한다.&lt;/p&gt;

&lt;p&gt;만약 이 상태에서 새로운 Activity가 종료되어 이전 Activity가 foreground에 나타나게 되면 시스템은 &lt;em&gt;onRestart()&lt;/em&gt;, &lt;em&gt;onStart()&lt;/em&gt;, &lt;em&gt;onResume()&lt;/em&gt; 콜백이 호출된다. 만약 덮여 있는 Activity의 인스턴스가 &lt;strong&gt;새로운 Activity 인스턴스&lt;/strong&gt;로 시작되는 경우 &lt;em&gt;onRestart()&lt;/em&gt; 콜백은 호출되지 않는다.&lt;/p&gt;

&lt;h2 id=&quot;user-taps-back-button&quot;&gt;User taps Back button&lt;/h2&gt;

&lt;p&gt;사용자가 백버튼을 눌러 Activity를 종료할 경우 &lt;em&gt;onPause()&lt;/em&gt;, &lt;em&gt;onStop()&lt;/em&gt;, &lt;em&gt;onDestroy()&lt;/em&gt; 콜백이 차례로 호출되면서 종료된다. 이 때 Activity는 백스택에서 제거된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;백버튼을 눌러 Activity를 종료할 경우 &lt;em&gt;onSaveInstanceState()&lt;/em&gt; 콜백은 실행되지 않는다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;프로세스와-앱-라이프사이클processes-and-application-lifecycle&quot;&gt;프로세스와 앱 라이프사이클(Processes and Application Lifecycle)&lt;/h1&gt;

&lt;p&gt;안드로이드 앱은 리눅스 프로세스안에서 실행되고, 이 프로세스는 코드를 실행할 때 앱을 위해 생성된다. 기본적으로 안드로이드 앱 프로세스는 직접적으로 제어되지 않는다. 대신 얼마나 사용자에게 얼마나 중요한지? 그리고 시스템에서 사용 가능한 전체 메모리의 양을 조합하여 시스템에 의해 제어된다.&lt;/p&gt;

&lt;p&gt;앱의 프로세스가 살아있는 동안 앱의 컴포넌트가 얼마나 이 앱에 영향을 끼치는지 이해하는것이 안드로이드 개발자에게 중요하다. 컴포넌트를 올바르게 사용하지 않으면, 앱의 프로세스가 중요한 작업을 하고 있을때 시스템에 의해 종료될 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;프로세스 라이프사이클 버그의 예제로는 &lt;em&gt;BroadcastReceiver.onReceive()&lt;/em&gt; 가 있다. 안드로이드 시스템은 일단 &lt;em&gt;BroadcastReceiver.onReceive()&lt;/em&gt; 메소드가 종료되면 더 이상 &lt;em&gt;BroadcastReceiver_는 활성화 되지 않는다고 간주하므로,(다른 앱의 컴포넌트가 _BroadcastReceiver&lt;/em&gt; 에서 활성화 되지 않는 이상) 프로세스 안에서 스레드가 실행되고 있어도 언제든지 종료될 수 있는 상황에 놓인다.
이 문제의 해결책은 &lt;em&gt;BroadcastReceiver&lt;/em&gt; 의 프로세스가 여전히 활성화 상태라고 시스템이 인지하게 하는 것이다. 그래서 JobService를 예약 하는 것으로 문제를 해결할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;안드로이드 프로세스에는 실행 중인 컴포넌트와 컴포넌트의 상태를 기반으로 우선순위 계층(importance hierarchy)이 존재하며, 메모리가 부족할 때 어떤 프로세스를 종료해야 쉽게 결정할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;포그라운드-프로세스foreground-process&quot;&gt;포그라운드 프로세스(foreground process)&lt;/h2&gt;

&lt;p&gt;첫 번째 우선순위를 가지는 foreground 프로세스이다. foreground 프로세스는 사용자와 현재 상호작용하고 있는 프로세스이며, 다양한 앱 컴포넌트로 인해 foreground 프로세스로 인식될 수 있다. foreground 프로세스로 인식될 수 있는 상황은 아래와 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;화면에서 Activity가 실행되어 사용자와 상호작용 하는 경우&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;BroadcastReceiver&lt;/em&gt; 가 현재 실행중인 경우(&lt;em&gt;BroadcastReceiver.onReceive()&lt;/em&gt; 가 실행중임)&lt;/li&gt;
  &lt;li&gt;Service에 콜백(&lt;em&gt;Service.onCreate()&lt;/em&gt;, &lt;em&gt;Service.onStart()&lt;/em&gt;, &lt;em&gt;Service.onDestroy()&lt;/em&gt;) 중 하나가 실행중인 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;포그라운드 프로세스는 메모리가 매우 부족하여 프로세스를 더 이상 실행할 수 없을때 최후의 방법으로만 종료된다.&lt;/p&gt;

&lt;h2 id=&quot;가시적-프로세스visible-process&quot;&gt;가시적 프로세스(visible process)&lt;/h2&gt;

&lt;p&gt;사용자가 현재 인식하고 있는 작업이므로 종료하게되면 사용자에게 매우 부정적인 영향을 끼치게 된다. 가시적 프로세스로 인식될 수 있는 상황은 아래와 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Activity가 실행중이지만 포그라운드 상태가 아닌경우&lt;/li&gt;
  &lt;li&gt;Service가 &lt;em&gt;포그라운드 서비스&lt;/em&gt; 로 실행중인 경우&lt;/li&gt;
  &lt;li&gt;프로세스가 live wallpaper, input method 같은 서비스를 호스팅하고 있는 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;가시적 프로세스도 포그라운드 프로세스에 비해 중요도가 약간 밀릴 뿐이지 중요한 프로세스로 인식된다. 포그라운드 프로세스를 계속 실행하기 위해 메모리가 필요한 상황이 아니면 종료되지 않는다.&lt;/p&gt;

&lt;h2 id=&quot;서비스-프로세스service-process&quot;&gt;서비스 프로세스(service process)&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Service.startService()&lt;/em&gt; 메소드로 실행된 서비스를 의미한다.&lt;/p&gt;

&lt;p&gt;안드로이드8 부터 보안이 강화되어 5초이상 실행되는 백그라운드 서비스는 언제든지 종료될 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;캐쉬-프로세스cached-process&quot;&gt;캐쉬 프로세스(cached process)&lt;/h2&gt;

&lt;p&gt;캐쉬 프로세스는 현재 필요한 것이 아니므로 언제든지 시스템이 종료하여 메모리를 회수해갈 수 있다. 메모리 관리 관점에서 보자면 일반적으로 시스템은 앱 스위칭을 효과적으로 진행하기 위해 여러개의 캐쉬 프로세스를 가지고 있으며, 오래된 프로세스를 필요에 따라 하나씩 종료한다. 매우 치명적인 상황인 경우에는 모든 캐쉬 프로세스를 종료하며 동시에 서비스 프로세스도 같이 종료된다.&lt;/p&gt;

&lt;p&gt;캐쉬 프로세스의 경우 사용자가 볼 수 없는 하나 이상의 Activity 인스턴스인 경우가 많다. Activity가 종료될 때 수명 주기를 올바르게 실행했다면 사용자가 해당 앱으로 다시 돌아갈 때 사용자에게 부정적인 영향을 끼치지 않을것이다.&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;설정변경이 일어났을 때 Activity는 파괴됐다가 재생성 된다.&lt;/li&gt;
  &lt;li&gt;백버튼을 눌러 Activity를 종료하는 경우 &lt;em&gt;onSaveInstanceState()&lt;/em&gt; 콜백은 호출되지 않는다.&lt;/li&gt;
  &lt;li&gt;안드로이드 프로세스는 실행 중인 컴포넌트와 컴포넌트의 상태를 기반으로 우선순위 계층이 존재한다.&lt;/li&gt;
  &lt;li&gt;포그라운드 프로세스 &amp;gt; 가시적 프로세스 &amp;gt; 서비스 프로세스 &amp;gt; 캐쉬 프로세스 순으로 우선순위를 가진다.&lt;/li&gt;
  &lt;li&gt;앱에서 급하게 메모리가 필요한 경우 캐쉬 프로세스와 서비스 프로세스를 모두 종료한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;참조&quot;&gt;참조&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.android.com/guide/components/activities/state-changes&quot;&gt;안드로이드 도큐먼트1&lt;/a&gt;
&lt;a href=&quot;https://developer.android.com/guide/components/activities/process-lifecycle&quot;&gt;안드로이드 도큐먼트2&lt;/a&gt;&lt;/p&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;avatar&quot;=&gt;nil, &quot;bio&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;links&quot;=&gt;[{&quot;label&quot;=&gt;&quot;Email&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-envelope-square&quot;}, {&quot;label&quot;=&gt;&quot;Website&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-link&quot;}, {&quot;label&quot;=&gt;&quot;Twitter&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-twitter-square&quot;}, {&quot;label&quot;=&gt;&quot;Facebook&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-facebook-square&quot;}, {&quot;label&quot;=&gt;&quot;GitHub&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-github&quot;}, {&quot;label&quot;=&gt;&quot;Instagram&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-instagram&quot;}]}</name></author><category term="Android" /><category term="Process" /><category term="State change" /><category term="Process with lifecycle" /><summary type="html">Activity 상태변경(State Change)</summary></entry><entry><title type="html">Android Process and thread</title><link href="http://localhost:4000/android/process-and-thread" rel="alternate" type="text/html" title="Android Process and thread" /><published>2020-02-27T00:00:00+09:00</published><updated>2020-03-01T00:00:00+09:00</updated><id>http://localhost:4000/android/android-process-thread</id><content type="html" xml:base="http://localhost:4000/android/process-and-thread">&lt;h1 id=&quot;processes-and-threads&quot;&gt;Processes and threads&lt;/h1&gt;

&lt;p&gt;한 앱(Application)의 컴포넌트(Component)가 실행되고 있지 않은 상황에서 앱이 실행될 때 안드로이드 시스템은 단일 스레드로 새로운 Linux 프로세스를 시작한다. 기본적으로 같은 앱의 컴포넌트는 같은 프로세스와 스레드(Main Thread)에서 시작된다. 하지만 앱과 컴포넌트를 위한 프로세스가 이미 있다면 컴포넌트는 이미 존재하는 프로세스와 스레드에서 실행된다. 그러나 한 앱에서 각각의 컴포넌트를 다른 프로세스에서 실행할 수 있게 설정할 수 있으며, 모든 프로세스에서 추가적인 스레드를 만들 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;processes&quot;&gt;Processes&lt;/h2&gt;

&lt;p&gt;일반적으로 모든 컴포넌트는 같은 앱, 같은 프로세스에서 실행되며 변경하는 것을 권장하지 않는다. 그러나 프로세스 제어가 필요한 상황이 있을 경우 &lt;strong&gt;Manifest&lt;/strong&gt;파일에서 제어할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Manifest&lt;/strong&gt;에는 &lt;strong&gt;Activity&lt;/strong&gt;, &lt;strong&gt;Service&lt;/strong&gt;, &lt;strong&gt;Receiver&lt;/strong&gt;, &lt;strong&gt;Provider&lt;/strong&gt;같은 각각의 컴포넌트에 대한 요소의 정보가 적혀있고, Manifest에는 해당 컴포넌트가 실행되는 프로세스를 지정할 수 있는 &lt;em&gt;android:process&lt;/em&gt; 속성을 지원한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;android:process&lt;/em&gt; 속성을 이용해 설정하면 컴포넌트를 아래와 같이 작동하도록 변경할 수 있다.&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;각 컴포넌트가 자체 프로세스에서 실행되도록 할 수 있다.&lt;/li&gt;
    &lt;li&gt;일부 컴포넌트가 프로세스를 공유하고 다른 컴포넌트는 공유하지 않도록 할 수 있다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;android:process&lt;/em&gt; 설정을 통해서 같은 Linux 사용자 아이디와 같은 인증서로 서명되도록 할 수 있고, 다른 앱의 컴포넌트를 동일한 프로세스에서 실행할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Manifest&lt;/strong&gt;의 &lt;em&gt;application&lt;/em&gt; 요소에도 &lt;em&gt;android:process&lt;/em&gt; 속성을 지원한다. &lt;em&gt;android:process&lt;/em&gt; 속성이 설정되면 &lt;strong&gt;모든 컴포넌트&lt;/strong&gt;에 속성이 적용된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;안드로이드 시스템이 메모리가 부족하거나 사용자에게 즉시 서비스를 제공하기 위해 프로세스에 필요한 경우, &lt;strong&gt;프로세스 종료 우선순위&lt;/strong&gt;에 의해 &lt;strong&gt;프로세스가 종료될 수 있다&lt;/strong&gt;. 종료된 프로세스에 따라서 프로세스 안의 실행중인 앱은 강제종료 된다. 하지만 컴포넌트가 다시 수행되면 해당 컴포넌트에 대한 프로세스가 다시 시작된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;프로세스 종료 우선순위는 &lt;a href=&quot;https://developer.android.com/guide/components/activities/process-lifecycle&quot;&gt;&lt;em&gt;여기&lt;/em&gt;&lt;/a&gt;를 참고하자.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;threads&quot;&gt;Threads&lt;/h2&gt;

&lt;p&gt;앱이 실행될 때 실행된 앱을 위해 안드로이드 시스템에서 하나의 스레드를 만들어 주는데 이것을 &lt;em&gt;메인 스레드&lt;/em&gt; 라고 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;안드로이드 시스템에서 &lt;em&gt;메인 스레드&lt;/em&gt;는 굉장히 중요하다. 왜 중요한지는 아래와 같다.&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;UI 그리기를 포함하여 적절한 사용자 UI에 이벤트를 전달한다.&lt;/li&gt;
    &lt;li&gt;앱에서 거의 모든 안드로이드 UI 툴킷 컴포넌트와 상호작용에 사용하는 스레드이다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;메인 스레드&lt;/em&gt;는 종종 &lt;em&gt;UI 스레드&lt;/em&gt; 라고 불린다. 특정 상황에서 메인 스레드가 UI 스레드가 아닐 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;다른 스레드상에서 복수의 뷰를 가지고 있는 시스템 앱&lt;/strong&gt;의 경우 UI 스레드와 메인 스레드가 다를 수 있다. 그래서 @UIThread 어노테이션은 앱의 뷰 계층에서만 사용해야 하고, @MainThread 어노테이션은 앱의 라이프사이클 관련 코드에서 사용해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;안드로이드 시스템은 각각의 인스턴스를 위해 스레드를 분리하지 않는다. 모든 컴포넌트는 같은 프로세스의 UI 스레드 안에서 초기화가 진행되고, UI 스레드에서 각각의 컴포넌트는 시스템의 호출을 전달받는다. 따라서 시스템 콜백 메소드는 항상 앱 프로세스의 UI 스레드에서 결과를 받는다.&lt;/p&gt;

&lt;p&gt;예를 들어, 한 화면에서 사용자가 버튼을 터치하면 터치 UI 스레드는 터치 이벤트를 해당 위젯(이 예제에서는 버튼)에 전달한다. 그리고 버튼이 눌린 상태에서 다시 눌리기 전 상태로 복귀하기 위해 이벤트 큐에 무효화 요청을 보내고, UI 스레드는 해당 요청을 이벤트 큐에서 꺼내어 위젯에 다시 그리라고 통보한다.&lt;/p&gt;

&lt;p&gt;사용자 상호작용에 응답하여 앱이 집중적인 작업을 수행할 때, 단일 스레드 모델은 앱을 제대로 구현하지 않으면 성능이 저하될 수 있다. 정확히 말하자면, 네트워크 작업이나 데이터베이스 작업을 UI 스레드에서 진행하는 경우 작업이 실행되는 동안 UI 스레드가 차단된다.&lt;/p&gt;

&lt;p&gt;UI 스레드가 차단되면, 그리기 이벤트 같은 이벤트들을 보낼 수 없고, 사용자 관점에서는 앱이 멈춰있는 것으로 보인다. 더 나쁜것은 UI 스레드가 몇 초 이상 차단되면 ANR 다이얼로그가 사용자에게 보여지고, 사용자는 앱을 강제종료 할 수 있으며, 이 행위는 앱의 삭제까지 이어질 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;추가적으로 안드로이드 UI 툴킷은 스레드에 안전하지 않다. 그래서 개발자는 UI를 UI 스레드 외의 스레드에서 조작하면 안된다. 이 말은 즉 UI 조작은 반드시 UI 스레드에서 이루어져야 하며, 안드로이드 단일 스레드 모델의 룰은 아래와 같다.&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;UI 스레드를 블록하면 안된다.&lt;/li&gt;
    &lt;li&gt;UI 스레드외의 스레드에서 안드로이드 UI 툴킷에 접근하면 안된다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;worker-thread&quot;&gt;Worker Thread&lt;/h2&gt;

&lt;p&gt;Thread 섹션에서 설명했듯이 UI 스레드를 차단하지 않는것이 매우 중요하다. 네트워크 작업, 데이터베이스 작업같이 긴 수행시간을 가진 작업을 수행할 경우 Background, Worker 스레드로 분리해서 작업해야 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Background, Worker 스레드에서 UI에 접근하면 안된다!!!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;안드로이드에서 외부 스레드(Background, Worker)에서 UI 스레드로 접근하는 몇가지 방법을 제공한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Activity.runOnUiThread(Runnable)&lt;/li&gt;
  &lt;li&gt;View.post(Runnable)&lt;/li&gt;
  &lt;li&gt;View.postDelayed(Runnable, long)&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onClick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;View&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// a potentially time consuming task&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;bitmap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;processBitMap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;image.png&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;imageView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;post&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;imageView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;setImageBitmap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bitmap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;위의&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;예제의&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;경우&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;외부&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;스레드에서&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;백그라운드&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;작업을&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;마친&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;후&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ImageView&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;조작은&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;항상&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UI&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;스레드에서&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;이루어&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;진다&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;thread-safe-method&quot;&gt;Thread safe method&lt;/h2&gt;

&lt;p&gt;특정 상황에서 하나의 스레드 이상에서 호출되는 메소드의 경우 스레드에 안전하도록 작성해야 한다.&lt;/p&gt;

&lt;p&gt;이 상황은 주로 바운드 서비스안에 있는 메소드 같이 메소드를 외부에서 호출하는 경우에 발생한다. &lt;em&gt;IBinder&lt;/em&gt; 에서 구현된 메소드에 대한 호출이 &lt;em&gt;IBinder&lt;/em&gt;가 실행되고 있는 것과 동일한 프로세스에서 실행중인 경우 호출자 스레드에서 메소드가 실행된다. 그러나 &lt;em&gt;IBInder&lt;/em&gt; 에서 구현된 메소드가 다른 프로세스에서 호출될 때 해당 메소드는 IBinder와 동일한 프로세스에서 시스템이 유지하고 있는 스레드 풀에서 선택한 스레드로 실행된다.(이 경우 프로세스의 UI 스레드에서는 실행되지 않는다.)&lt;/p&gt;

&lt;p&gt;예를들어 서비스 프로세스의 UI 스레드에서 서비스의 &lt;em&gt;onBind()&lt;/em&gt; 메소드를 호출하지만, &lt;em&gt;onBind()&lt;/em&gt;가 반환하는 객체는 스레드 풀 안의 다른 스레드로부터 호출된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;서비스는 한 개 이상의 클라이언트를 가질 수 있고, 한 개 이상의 스레드 풀 안의 스레드가 &lt;strong&gt;동시에&lt;/strong&gt; &lt;strong&gt;동일한&lt;/strong&gt; &lt;em&gt;IBinder&lt;/em&gt; 메소드를 사용할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;마찬가지로 &lt;em&gt;컨텐트프로바이더&lt;/em&gt;는 다른 프로세스에서 발생하는 데이터 요청을 받을 수 있다. &lt;em&gt;컨텐트리졸버&lt;/em&gt; 및 &lt;em&gt;컨텐트프로바이더&lt;/em&gt; 클래스는 프로세스 간 IPC 관리 방법에 관한 자세한 사항은 숨기지만, &lt;strong&gt;이러한 요청&lt;/strong&gt;에 응답하는 &lt;em&gt;컨텐트프로바이더&lt;/em&gt; 메소드는 프로세스에 대한 UI 스레드가 아니라, &lt;em&gt;컨텐트프로바이더&lt;/em&gt; 프로세스안의 스레드 풀에서 호출된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이러한 요청 이란?
컨턴트프로바이드 메소드 - &lt;em&gt;query()&lt;/em&gt;, &lt;em&gt;insert()&lt;/em&gt;, &lt;em&gt;delete()&lt;/em&gt;, &lt;em&gt;update()&lt;/em&gt;, &lt;em&gt;getType()&lt;/em&gt; 를 의미한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;interprocess-communication&quot;&gt;Interprocess communication&lt;/h2&gt;

&lt;p&gt;안드로이드는 RPC(remote procedure) 호출을 이용한 IPC(interprocess communication) 메커니즘을 제공하는데, 이 메커니즘은 특정 메소드가 Activity나 다른 앱의 컴포넌트에 의해 호출되는 지만 원격으로 실행되고, 결과도 호출자에게 전달된다.&lt;/p&gt;

&lt;p&gt;여기에는 메소드 호출과 그 데이터를 운영체제가 이해할 수 있는 수준으로 분해하여 로컬 프로세스 주소 공간에서 원격 프로세스 주소 공간으로 전송한 다음, 거기서 메소드 호출을 재조립하고 다시 재연하는 작업을 진행한다.&lt;/p&gt;

&lt;p&gt;그런 다음 반환 값은 반대 방향으로 전송된다. Android는 이러한 IPC 트랜잭션을 수행하기 위한 모든 코드를 제공하므로 RPC 프로그래밍 인터페이스를 정의하고 구현하는 데 집중할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;요약&quot;&gt;요약&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;(기존에 프로세스가 존재하지 않는다는 전제하에)앱이 실행될 때 메인스레드로 Linux 프로세스를 시작한다.&lt;/li&gt;
  &lt;li&gt;Manifest에서 각 컴포넌트별 프로세스를 설정 가능하다. (application 요소에 프로세스를 설정하게 되면, 하위 컴포넌트는 application에서 설정한 프로세스를 따라가게 된다.)&lt;/li&gt;
  &lt;li&gt;메인 스레드가 종종 UI 스레드라고 불리지만, 메인 스레드가 UI 스레드가 아닌 경우도 발생한다.&lt;/li&gt;
  &lt;li&gt;메인 스레드가 차단되지 않게 주의해야 하고, 작업 시간이 긴 작업의 경우 Worker 스레드로 실행해야 한다.&lt;/li&gt;
  &lt;li&gt;한 개 이상의 스레드에서 불릴 가능성이 있는 메소드는 스레드에 안전하도록 작성해야 한다.(바운드 서비스의 메소드 등)&lt;/li&gt;
  &lt;li&gt;안드로이드는 IPC 메커니즘을 제공한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;참조&quot;&gt;참조&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.android.com/guide/components/processes-and-threads&quot;&gt;안드로이드 도큐먼트&lt;/a&gt;&lt;/p&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;avatar&quot;=&gt;nil, &quot;bio&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;links&quot;=&gt;[{&quot;label&quot;=&gt;&quot;Email&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-envelope-square&quot;}, {&quot;label&quot;=&gt;&quot;Website&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-link&quot;}, {&quot;label&quot;=&gt;&quot;Twitter&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-twitter-square&quot;}, {&quot;label&quot;=&gt;&quot;Facebook&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-facebook-square&quot;}, {&quot;label&quot;=&gt;&quot;GitHub&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-github&quot;}, {&quot;label&quot;=&gt;&quot;Instagram&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-instagram&quot;}]}</name></author><category term="Android" /><category term="Process" /><category term="Thread" /><summary type="html">Processes and threads</summary></entry><entry><title type="html">Android Activity - 3</title><link href="http://localhost:4000/android/activity3" rel="alternate" type="text/html" title="Android Activity - 3" /><published>2020-02-25T00:00:00+09:00</published><updated>2020-02-26T00:00:00+09:00</updated><id>http://localhost:4000/android/android-activity-03</id><content type="html" xml:base="http://localhost:4000/android/activity3">&lt;h2 id=&quot;activity-ejection-memory&quot;&gt;Activity ejection memory&lt;/h2&gt;

&lt;p&gt;안드로이드에서 메모리 용량이 부족하면 시스템이 프로세스를 강제종료하여 메모리를 확보하는데, 이 때 시스템이 강제종료하는 프로세스는 &lt;strong&gt;프로세스의 상태&lt;/strong&gt;에 관련이 있고, 프로세스의 상태는 &lt;strong&gt;프로세스 안에서 활동중인 Activity의 상태&lt;/strong&gt;와 연관이 있다. 아래의 표는 프로세스의 상태, Activity의 상태 및 시스템이 프로세스를 종료시키는 우선순위를 표시한 것이다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;시스템에 의해 강제종료될 가능성&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;프로세스 상태&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Activity 상태&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Least&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Foreground&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Create&lt;br /&gt;Started &lt;br /&gt; resumed&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;More&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Background(lost focus)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Paused&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Most&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Background(not visible)&lt;br /&gt;Empty&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Stoped&lt;br /&gt;Destroyed&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;시스템은 Activity를 메모리에서 직접적으로 강제종료 하지 않는 대신 Activity가 실행되고 있는 프로세스를 종료하여 Activity 뿐만 아니라 프로세스에서 실행되고있는 모든것을 같이 종료한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;사용자가 설정메뉴 안에 있는 앱관리 메뉴에서 프로세스를 강제종료 시킬 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;saving-and-restore-transient-ui-state&quot;&gt;Saving and restore transient UI state&lt;/h2&gt;

&lt;p&gt;사용자는 설정변경(가로모드에서 세로모드, 세로모드에서 가로모드로 변경될 때)이 일어날 때 UI(User Interface)의 상태가 그대로 일 것이라고 기대하지만, 안드로이드 에서는 그런 설정변경이 일어날 때 기본적으로 Activity를 강제종료 후 재생성 하므로 기존에 사용했던 UI를 제거하고 다시 생성한다.(즉 처음으로 돌아간다.)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;유사하게 사용자가 앱을 사용하다가, 다른 앱으로 이동하거나 장시간 사용한 앱을 백그라운드에 두고 다시 돌아왔을 때 마지막에 사용했던 상태와 같은 상태일거라고 생각하지만, 왠만하면 시스템이 앱 프로세스를 종료하기 때문에 첫 스텝부터 다시 시작한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;우리는 위와같이 안드로이드 시스템 제약에 의해서 Activity가 종료되는 상황 속에서 ViewModel, onSaveInstanceState, Local Storage(Local database)를 사용해 UI 데이터를 보호해야 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이 포스팅의 예제에서는 &lt;strong&gt;onSaveInstanceState&lt;/strong&gt;를 기반으로 다룰것이다. &lt;strong&gt;onSaveInstanceState&lt;/strong&gt;는 설정변경이 일어나거나, 안드로이드 시스템에 의해 프로세스가 강제종료되고 다시 시작했을 때 UI 상태가  가볍다면(기본 타입이거나 String 같은 가벼운 객체일 때) 이를 유지할 수 있다. 하지만 대부분의 경우 &lt;strong&gt;onSaveInstanceState&lt;/strong&gt;에서 직렬화 비직렬화 이슈가 발생하기 때문에 사용한다면 &lt;strong&gt;ViewModel&lt;/strong&gt;과 &lt;strong&gt;onSaveInstanceState&lt;/strong&gt;를 같이 사용 할 것을 권장하고 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;instance-state&quot;&gt;Instance state&lt;/h2&gt;

&lt;p&gt;사용자가 뒤로가기 버튼을 이용하여 종료하거나, &lt;strong&gt;finish()&lt;/strong&gt; 메소드를 이용하여 Activity를 종료하면 개발자는 &lt;strong&gt;아무 처리를 하지 않아도 된다.&lt;/strong&gt; 하지만 안드로이드 시스템 제약으로 Activity가 강제종료 됐을때 시스템은 이 Activity가 존재했다는 것을 기억을 하고 있고, 사용자가 다시 시스템에 의해 강제종료된 Activity를 실행할 때 이전 강제종료된 Activity의 마지막 상태를 참고하여 시스템은 새로운 Activity를 실행 한다.&lt;/p&gt;

&lt;p&gt;시스템이 이전 상태를 복원하는데 사용하는 데이터를 인스턴스 상태(Instance State)라고 하며, 이것은 Key-Value 페어로 이루어진 Bundle 객체이다. 기본적으로 시스템은 Bundle 객체를 이용하여 각각의 View의 상태를 저장하며, Activity가 시스템 제약에 의해 강제종료 되고 재생성될때 &lt;strong&gt;개발자의 추가적인 코드 없이&lt;/strong&gt; Bundle 객체를 이용하여 View의 상태를 복원 한다.(EditText안의 있는 텍스트 같은 값)&lt;/p&gt;

&lt;p&gt;그러나 Bundle은 큰 데이터를 저장하는데 적합하지 않다. 왜냐하면 Bundle 객체는 직렬화를 메인 쓰레드에 요청하고, 시스템 프로세스 메모리를 사용하기 때문이다. 결국 UI 상태를 저장하려면 local datastorage, onSaveInstanceState, ViewModel을 적절히 조합하여 사용해야 한다.&lt;/p&gt;

&lt;h2 id=&quot;save-ui-state-using-onsaveinstancestate&quot;&gt;Save UI state using onSaveInstanceState&lt;/h2&gt;

&lt;p&gt;Activity가 &lt;strong&gt;OnStop&lt;/strong&gt;콜백을 호출한 다음 &lt;strong&gt;onSaveInstanceState&lt;/strong&gt;를 호출하여 인스턴스 상태 Bundle 객체에 추가적인 데이터를 저장할 기회를 준다. 아래와 같이 &lt;strong&gt;onSaveInstanceState&lt;/strong&gt; 메소드를 재정의 하여 사용할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onSaveInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;outState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Save the user's current game state&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;outState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;putInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;STATE_SCORE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentScore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;putInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;STATE_LEVEL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentLevel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Always call the superclass so it can save the view hierarchy state&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onSaveInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;outState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;companion&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;STATE_SCORE&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;playerScore&quot;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;STATE_LEVEL&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;playerLevel&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;이전에도 언급 했듯이 사용자의 데이터나, DataBase의 데이터를 저장할 적당한 장소를 찾지 못한다면 onStop 에서 데이터를 저장 하는것이 좋다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;restore-activity-ui-state-using-saved-instance-state&quot;&gt;Restore activity UI state using saved instance state&lt;/h2&gt;

&lt;p&gt;Activity가 재생성 됐을 때 이전에 저장한 데이터를 이용하여 &lt;strong&gt;onCreate&lt;/strong&gt; or &lt;strong&gt;onRestoreInstanceState&lt;/strong&gt;를 이용하여 복원할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;&lt;strong&gt;onCreate&lt;/strong&gt;나 &lt;strong&gt;onRestoreInstnaceState&lt;/strong&gt;에는 같은 Bundle 객체가 파라미터를 통해 전달된다.&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;Activity가 재생성 될 때 시스템이 새 인스턴스를 만드는지 혹은 기존의 인스턴스를 재사용하는지의 여부에 관계 없이 &lt;strong&gt;onCreate&lt;/strong&gt; 콜백은 실행된다. 이곳에서 파라미터로 넘어오는 &lt;strong&gt;Bundle&lt;/strong&gt; 객체는 nullable 이기 때문에 접근할 때 주의해야 한다. 예제코드는 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Always call the superclass first&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Check whether we're recreating a previously destroyed instance&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// Restore value of members from saved state&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;currentScore&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;STATE_SCORE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;currentLevel&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;STATE_LEVEL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Probably initialize members with default values for a new instance&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 &lt;strong&gt;onCreate&lt;/strong&gt; 대신 &lt;strong&gt;onRestoreInstanceState&lt;/strong&gt;를 사용한다고 하면, 이 콜백은 &lt;strong&gt;onStart&lt;/strong&gt; 이후에 호출된다. 이 콜백은 onCreate와 다르게 Bundle 객체의 null 체크가 필요없다. 왜냐하면 Bundle을 통해 넘어온 객체가 있는 경우에만 &lt;strong&gt;onRestoreInstanceState&lt;/strong&gt; 콜백이 호출되기 떄문이다. 구현은 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onRestoreInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Always call the superclass so it can restore the view hierarchy&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onRestoreInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Restore state members from saved instance&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;currentScore&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;STATE_SCORE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;currentLevel&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;STATE_LEVEL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;안드로이드 공식홈페이지 에서 말로는 Null 체크를 하지 않아도 된다고 적혀 있지만, Kotlin의 안전한 Null 처리를 이용하여 처리를 했다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;참조&quot;&gt;참조&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.android.com/guide/components/activities/activity-lifecycle#saras&quot;&gt;안드로이드 도큐먼트&lt;/a&gt;&lt;/p&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;avatar&quot;=&gt;nil, &quot;bio&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;links&quot;=&gt;[{&quot;label&quot;=&gt;&quot;Email&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-envelope-square&quot;}, {&quot;label&quot;=&gt;&quot;Website&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-link&quot;}, {&quot;label&quot;=&gt;&quot;Twitter&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-twitter-square&quot;}, {&quot;label&quot;=&gt;&quot;Facebook&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-facebook-square&quot;}, {&quot;label&quot;=&gt;&quot;GitHub&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-github&quot;}, {&quot;label&quot;=&gt;&quot;Instagram&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-instagram&quot;}]}</name></author><category term="Android" /><category term="Activity" /><category term="Other" /><summary type="html">Activity ejection memory</summary></entry><entry><title type="html">Android Activity - 2</title><link href="http://localhost:4000/android/activity2" rel="alternate" type="text/html" title="Android Activity - 2" /><published>2020-02-23T00:00:00+09:00</published><updated>2020-02-24T00:00:00+09:00</updated><id>http://localhost:4000/android/android-activity-02</id><content type="html" xml:base="http://localhost:4000/android/activity2">&lt;h1 id=&quot;activity-lifecycle&quot;&gt;Activity Lifecycle&lt;/h1&gt;

&lt;p&gt;사용자가 앱(Application)을 사용, 종료, 탐색등을 할 때 Activity의 lifecycle은 각각의 상태에 맞게 전환된다. 그에 따라 개발자는 Activity의 lifecycle에 적절한 행동을 정의 해야 하고, 잘 정의하게 되면 아래와 같은 문제를 피할 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;사용자가 전화를 받거나 다른 앱으로 전환 했을 때 앱이 강제종료되는 것을 피할 수 있다.&lt;/li&gt;
  &lt;li&gt;사용자가 앱을 사용하지 않을 때, 시스템 자원을 낭비하는 것을 막을 수 있다.&lt;/li&gt;
  &lt;li&gt;사용자가 앱을 떠나 나중에 다시 돌아오게 될 때, 사용자의 현재 상태를 잃는 것을 방지할 수 있다.&lt;/li&gt;
  &lt;li&gt;사용자가 화면을 전환할 때,(가로모드, 세로모드) 사용자의 현재 상태를 잃거나, 앱이 강제종료 되는것을 방지할 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;Activity의 복잡성에 따라 lifecycle 메소드를 구현이 필요하거나 필요하지 않을 수 있지만, 더욱 안전한 앱을 위해 lifecycle 메소드를 이해하고 구현해보는것이 중요하다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;lifecycle의 중요 메소드는 6가지가 있다. 하나씩 살펴보자.&lt;/p&gt;

&lt;h2 id=&quot;oncreate&quot;&gt;onCreate&lt;/h2&gt;

&lt;p&gt;Activity가 생성될 때 발생하는 콜백이다. Activity가 살아있을 때 단 한번만 불려서 시작을 위한 로직 대부분을 &lt;strong&gt;onCreate&lt;/strong&gt; 에서 선언한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;파라미터로 saveInstanceState란 Bundle 객체가 넘어오는데, 이전에 저장한 상태값이 있으면 이 파라미터로 넘어오고 아니면 null이 반환된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;간단한 구현을 보면 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;lateinit&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;textView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TextView&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// some transient state for the activity instance&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;gameState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// call the super class onCreate to complete the creation of activity like&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// the view hierarchy&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// recovering the instance state&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;gameState&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;GAME_STATE_KEY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// set the user interface layout for this activity&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// the layout file is defined in the project res/layout/main_activity.xml file&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;setContentView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main_activity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// initialize member TextView so we can manipulate it later&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;textView&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;findViewById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text_view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// This callback is called only when there is a saved instance that is previously saved by using&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// onSaveInstanceState(). We restore some state in onCreate(), while we can optionally restore&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// other state here, possibly usable after onStart() has completed.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// The savedInstanceState Bundle is same as the one used in onCreate().&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onRestoreInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;textView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TEXT_VIEW_KEY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// invoked when the activity may be temporarily destroyed, save the instance state here&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onSaveInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;outState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;outState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;putString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;GAME_STATE_KEY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gameState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;putString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TEXT_VIEW_KEY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;textView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// call superclass to save any view hierarchy&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onSaveInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;outState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;setContentView에 layout xml을 전달하는 대신, 새로운 View를 만들어 ViewGroup에 추가하고 ViewGroup의 root를 setContentView에 전달하는 방법을 사용할 수 있다. 자세한 내용은 &lt;a href=&quot;https://developer.android.com/guide/topics/ui&quot;&gt;여길&lt;/a&gt; 참조하자&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;onstart&quot;&gt;onStart&lt;/h2&gt;

&lt;p&gt;Activity가 시작 상태로 진입했을 때 발생하는 콜백이다. &lt;strong&gt;onStart&lt;/strong&gt; 콜백이 발생했을 때는 해당 Activity가 사용자에게 보여진다는 것을 의미한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;onStart 콜백은 매우 빠르게 완료되고 바로 다음 상태인 onResume 상태로 넘어간다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;onresume&quot;&gt;onResume&lt;/h2&gt;

&lt;p&gt;Activity가 재개 상태로 진입했을 때 발생하는 콜백이다. &lt;strong&gt;onResume&lt;/strong&gt; 콜백이 불린다는 것은 해당 Activity가 Foreground에 진입했다는 것이고, 사용자와 상호작용을 할 수 있다는 것을 의미한다. 다른 상태전환(Activity 이동 또는 종료)이 일어나기 전까지 해당 Activity는 이 상태를 유지한다.&lt;/p&gt;

&lt;h2 id=&quot;onpause&quot;&gt;onPause&lt;/h2&gt;

&lt;p&gt;사용자가 Activity에서 떠날때 가장 먼저 발생하는 콜백이 &lt;strong&gt;onPause&lt;/strong&gt; 이다. Activity가 Pause 상태로 진입하여 Activity가 더이상 Foreground에 있지 않다는걸 의미한다.&lt;/p&gt;

&lt;p&gt;onPause의 경우 매우 짧은 시간안에 끝나기 때문에 저장 작업 같은 긴 작업을 하기에 적합하지 않다. 이말은 즉 저장작업, 네트워크 작업 등을 onPause에서 하지 말라는 의미이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;onPause에서 위와 같은 작업을 실행하게 되면, onPause 메소드가 끝날 때 까지 해당 작업이 완료되지 않을 수 있다. 이러한 무거운 작업은 onStop 에서 해야한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;onPause 작업이 완료되면 Activity가 일시정지 상태를 벗어났다는 의미이다. 그리고 Activity가 일시정지 상태를 벗어나면, 다시 재개되거나, 사용자에게 아얘 안보인다는 것이고, 만약 Activity 가 재개됐다면 &lt;strong&gt;onResume&lt;/strong&gt; 콜백이 다시 호출되게 된다. onResume 콜백이 불리게 된 상황에서는 Activity 인스턴스가 메모리에 계속 거주하게 된다. 이 시나리오 대로라면 Activity는 다른 라이프사이클 콜백에서 초기화 작업을 수행하지 않아도 되며, 종료 시나리오를 타는 경우 사용자에게 아얘 안보이게 되고 &lt;strong&gt;onStop&lt;/strong&gt; 콜백이 실행되게 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;onstop&quot;&gt;onStop&lt;/h2&gt;

&lt;p&gt;Activity가 사용자에게 더이상 보이지 않을 때 정지 상태에 돌입한다. 그리고 그 즉시 시스템은 &lt;strong&gt;onStop&lt;/strong&gt; 콜백을 호출하게 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;onStop&lt;/strong&gt;이 불리게 될때 새로운 Activity가 실행되어 기존 Activity를 가리거나, 기존 Activity가 종료 로직을 수행하게 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;일시정지 애니메이션이나 세밀한 위치정보 업데이트 같은, 불필요하거나 조정해야 하는 리소스는 onStop에서 수행해야 한다. 또한 데이터베이스에 데이터 저장 같은 CPU를 사용하는 작업은 적당한 수행장소를 찾지 못했을 경우 onStop에서 수행해야 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Activity가 정지 상태일 때 &lt;strong&gt;Window Manager를 제외한&lt;/strong&gt; 모든 상태와 정보를 가지고 메모리에 계속 거주하고 있게 된다.(Activity가 재개될 때 Window Manager에 필요한 정보를 다시 호출한다.) &lt;strong&gt;onPause&lt;/strong&gt; 콜백과 같이 재개됐을 때는 다른 라이프사이클 콜백에서 초기화 작업을 수행하지 않아도 되며, onStop에서 정리한 리소스들을 onStart에서 적절히 재수행 시켜주기만 하면 된다. 재수행 될 경우 onRestart 콜백이 불리게 되고, 종료 프로세스를 수행하는 경우 onDestroy 콜백이 불리게 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;ondestroy&quot;&gt;onDestroy&lt;/h2&gt;

&lt;p&gt;Activity가 종료되기 전에 호출되는 콜백이다. 아래와 같은 상황에 수행된다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;유저가 종료하거나, finish() 함수가 불리는 경우&lt;/li&gt;
  &lt;li&gt;Configuration change 가 일어나는 경우&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Activity의 종료 이유를 찾기 보단, &lt;strong&gt;ViewModel을 이용&lt;/strong&gt;하여 View의 데이터를 적절히 가지고 있어야 한다. Configuration Change가 일어나 해당 Activity 파괴되고 다시 생성되는 경우에도 ViewModel은 다시 생성되는 Activity 인스턴스에 제공되므로 아무것도 수행하지 않아도 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Activity가 재생성되지 않고 파괴되는 경우 ViewModel은 &lt;strong&gt;onCleared&lt;/strong&gt; 함수가 호출 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;onDestroy 콜백에서 해당 Activity에서 사용하는 resource들을 최대한 해제시켜야 한다.&lt;/p&gt;

&lt;h2 id=&quot;참조&quot;&gt;참조&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.android.com/guide/components/activities/activity-lifecycle&quot;&gt;안드로이드 도큐먼트&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;avatar&quot;=&gt;nil, &quot;bio&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;links&quot;=&gt;[{&quot;label&quot;=&gt;&quot;Email&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-envelope-square&quot;}, {&quot;label&quot;=&gt;&quot;Website&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-link&quot;}, {&quot;label&quot;=&gt;&quot;Twitter&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-twitter-square&quot;}, {&quot;label&quot;=&gt;&quot;Facebook&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-facebook-square&quot;}, {&quot;label&quot;=&gt;&quot;GitHub&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-github&quot;}, {&quot;label&quot;=&gt;&quot;Instagram&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-instagram&quot;}]}</name></author><category term="Android" /><category term="Activity" /><category term="Activity Lifecycle" /><summary type="html">Activity Lifecycle</summary></entry><entry><title type="html">Android Activity - 1</title><link href="http://localhost:4000/android/activity1" rel="alternate" type="text/html" title="Android Activity - 1" /><published>2020-02-20T00:00:00+09:00</published><updated>2020-02-23T00:00:00+09:00</updated><id>http://localhost:4000/android/android-activity-01</id><content type="html" xml:base="http://localhost:4000/android/activity1">&lt;h1 id=&quot;activity&quot;&gt;Activity&lt;/h1&gt;

&lt;p&gt;Activity는 한 앱이 다른 앱을 호출할 때 호출 앱은 다른 앱을 전체적으로 호출하는 것이 아니라 &lt;em&gt;다른 앱의 Activity를&lt;/em&gt; 호출한다. Activity는 이러한 패러다임으로 설계되었으며, 앱과 사용자의 상호작용을 담당한다.&lt;/p&gt;

&lt;p&gt;또한, Activity는 화면(Screen)보다 작거나, 다른 Window위에 나타날 수 있는 Window를 제공하고 있으며, 이 Window는 User Interface를 그려 화면을 채운다.&lt;/p&gt;

&lt;p&gt;이처럼 Activity는 Android Component중 가장 중요한 역할을 맡고 있다. Activity를 관리하려면 Manifest에 등록해야 하며, Lifecycle과 &lt;a href=&quot;https://gyooha.github.io/seroo/android/backstack&quot;&gt;Backstack&lt;/a&gt;을 적절하게 관리해야 한다.&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;manifest&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;application&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;activity&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;.ExampleActivity&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
      ...
  &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;/application ... &amp;gt;
  ...
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/manifest &amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;매니페스트(Manifest)에 위와 &lt;application&gt; 안에 &lt;activity&gt; 태그를 이용하여 등록이 가능하다.&lt;/activity&gt;&lt;/application&gt;&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;activity&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;.ExampleActivity&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:icon=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@drawable/app_icon&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;intent-filter&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;action&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;android.intent.action.SEND&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;category&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;android.intent.category.DEFAULT&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;data&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:mimeType=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/plain&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/intent-filter&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/activity&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 intent-filter 설정도 가능하다. 자세한 내용은 다음 Intent component 시간에 하도록 하겠다.&lt;/p&gt;

&lt;h2 id=&quot;activity-lifecycle&quot;&gt;Activity Lifecycle&lt;/h2&gt;

&lt;h3 id=&quot;oncreate&quot;&gt;onCreate&lt;/h3&gt;

&lt;p&gt;Activity가 생성되면 가장 먼저 불리게 되는 콜백함수 이다. 그래서 가장 먼저 구현해야 하며, setContentView 메소드를 이용하여 layout을 정의해야 하고, list 등의 데이터를 View에 bind 시켜줘야 한다. onCreate 다음 콜백은 항상 onStart 이다.&lt;/p&gt;

&lt;h3 id=&quot;onstart&quot;&gt;onStart&lt;/h3&gt;

&lt;p&gt;onStart 콜백은 Activity가 시작 상태에 들어와있다는 뜻이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;시작상태란? - Activity가 Foreground에 와서 사용자와 상호작용할 준비가 완료 됐다는 의미 이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;onresume&quot;&gt;onResume&lt;/h3&gt;

&lt;p&gt;onResume 콜백이 시작되면 해당 Activity가 Activity Stack의 Top에 와있다는 것이며, 사용자와 상호작용을 시작했다는 뜻이다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;onPause 콜백은 항상 onResume 다음에 불린다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;onpause&quot;&gt;onPause&lt;/h3&gt;

&lt;p&gt;onPause 콜백이 시작되면 해당 Activity가 포커스를 잃고 Pause 상태에 들어갔다는 의미이다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;onPause 콜백이 호출되면 Activity는 부분적으로 보일순 있지만, 그러나 대부분 해당 Activity 떠난다는 의미이며, 다음콜백(onResume, onStop)을 호출하게 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;주의사항 - onPause에서는 user data를 저장하거나, Network Call을 하거나, database transaction 작업을 하지 않는것을 권장한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;onstop&quot;&gt;onStop&lt;/h3&gt;

&lt;p&gt;onStop 콜백이 시작되면 해당 Activity의 UI가 더이상 사용자에게 보이지 않는다는 것을 의미한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;대부분 이전 Activity는 파괴되고, 새로운 Activity는 생성중 이거나, 존재하는 Activity가 Resume 상태로 돌입하여 Stop된 Activity를 덮는 행동을 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;onrestart&quot;&gt;onRestart&lt;/h3&gt;

&lt;p&gt;onRestart 콜백은 Activity가 Stop 상태에서 다시 재시작 될 때 호출된다. Activity가 중지될 때의 상태를 복원한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;다음 콜백은 항상 onStart 이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;ondestroy&quot;&gt;onDestroy&lt;/h3&gt;
&lt;p&gt;onDestroy 콜백은 Activity가 마지막 한번만 받게 된다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;onDestroy에서는 Activity 또는 Activity를 포함하는 프로세스가 파괴될 때 resource를 해제하기 위해 구현된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;참조&quot;&gt;참조&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.android.com/reference/android/app/Activity&quot;&gt;Activity document&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.android.com/guide/components/activities/intro-activities&quot;&gt;Activity guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;avatar&quot;=&gt;nil, &quot;bio&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;links&quot;=&gt;[{&quot;label&quot;=&gt;&quot;Email&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-envelope-square&quot;}, {&quot;label&quot;=&gt;&quot;Website&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-link&quot;}, {&quot;label&quot;=&gt;&quot;Twitter&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-twitter-square&quot;}, {&quot;label&quot;=&gt;&quot;Facebook&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-facebook-square&quot;}, {&quot;label&quot;=&gt;&quot;GitHub&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-github&quot;}, {&quot;label&quot;=&gt;&quot;Instagram&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-instagram&quot;}]}</name></author><category term="Android" /><category term="Activity" /><summary type="html">Activity</summary></entry><entry><title type="html">자료구조 - 그래프</title><link href="http://localhost:4000/datastructure/graph" rel="alternate" type="text/html" title="자료구조 - 그래프" /><published>2020-02-14T00:00:00+09:00</published><updated>2020-02-14T00:00:00+09:00</updated><id>http://localhost:4000/datastructure/graph</id><content type="html" xml:base="http://localhost:4000/datastructure/graph">&lt;h1 id=&quot;그래프graph&quot;&gt;그래프(Graph)&lt;/h1&gt;

&lt;p&gt;그래프는 단순히 노드와 노드 사이를 연결한 것을 하나로 모아 놓은 것과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이전에 포스팅한 트리도 그래프의 한 종류이다. 하지만 그렇다고 모든 그래프가 트리인 것은 아니다. 간단히 말해서 트리는 사이클이 없는 하나의 연결 그래프이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;그래프의-특징&quot;&gt;그래프의 특징&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;그래프는 방향성이 있을 수도 있고 없을 수도 있다.&lt;/li&gt;
  &lt;li&gt;그래프는 여러 개의 고립된 부분 그래프(isolated subgraphs)로 구성될 수 있다. 모든 정점 쌍 간에 경로가 존재하는 그래프는 “연결 그래프” 라고 부른다.&lt;/li&gt;
  &lt;li&gt;그래프는 사이클이 존재할 수도 있고, 존재하지 않을 수도 있다. 사이클이 없는 그래프는 “비순환 그래프(acycle graph)” 라고 부른다.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;half full&quot;&gt;
  
    
      &lt;a href=&quot;/assets/images/posts/image_graph_01.png&quot; title=&quot;그래프 예제1&quot;&gt;
        &lt;img src=&quot;/assets/images/posts/image_graph_01.png&quot; alt=&quot;그래프&quot; /&gt;
      &lt;/a&gt;
    
  
    
      &lt;a href=&quot;/assets/images/posts/image_graph_02.png&quot; title=&quot;그래프 예제2&quot;&gt;
        &lt;img src=&quot;/assets/images/posts/image_graph_02.png&quot; alt=&quot;그래프&quot; /&gt;
      &lt;/a&gt;
    
  
  
    &lt;figcaption&gt;
&lt;/figcaption&gt;
  
&lt;/figure&gt;

&lt;p&gt;프로그래밍 관점에서 그래프를 표현할 때는 일반적으로 다음 두 가지 방법을 사용한다.&lt;/p&gt;

&lt;h2 id=&quot;인접-리스트adjacency-list&quot;&gt;인접 리스트(adjacency list)&lt;/h2&gt;

&lt;p&gt;인접 리스트는 그래프를 표현할 때 사용되는 가장 일반적인 방법이다. 모든 노드를 인접 리스트에 저장한다. 무방향 그래프에서 a, b 간선은 두 번 저장 된다. 한 번은 a 노드에 인접한 간선을 저장하고 다른 한번은 b에 인접한 간선을 저장한다.&lt;/p&gt;

&lt;p&gt;간단하게 구현하면 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MutableList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;data class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MutableList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;트리에서는 루트 노드에서 모든 노드를 접근할 수 있기 때문에, 트리 클래스를 따로 두지 않아도 됬었다. 하지만 그래프에서는 하나의 노드에서 모든 노드로 접근할 수 없기 때문에 Graph 클래스가 필요하다.&lt;/p&gt;

&lt;p&gt;그래프를 표현하기 위한 추가적인 클래스를 따로 만들 필요는 없다. 배열 혹은 해시테이블과 해당 자료구조의 인덱스마다 존재하는 또 다른 리스트(배열, 가변리스트, 연결리스트)를 이용해서 인접 리스트를 표현할 수 있다.&lt;/p&gt;

&lt;p&gt;위의 그림과 같은 그래프는 다음과 같이 표현할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0: 1
1: 2
2: 0, 3
3: 2

4: 6
5: 4
6: 5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;인접-행렬&quot;&gt;인접 행렬&lt;/h2&gt;

&lt;p&gt;인접 행렬은 NXN Boolean 행렬로써 matrix[i][j]가 true라면 i에서 j로의 간선이 있다는 뜻이다. 0과 1을 이용한 정수 행렬을 사용할 수도 있다. 여기서 N은 노드의 개수를 의미한다.&lt;/p&gt;

&lt;p&gt;무방향 그래프를 인접 행렬로 표현한다면 이 행렬은 대칭행렬이 된다. 방향 그래프에서는 대칭행렬이 안 될 수도 있다.&lt;/p&gt;

&lt;figure class=&quot;half full&quot;&gt;
  
    
      &lt;a href=&quot;/assets/images/posts/image_graph_02.png&quot; title=&quot;그래프&quot;&gt;
        &lt;img src=&quot;/assets/images/posts/image_graph_02.png&quot; alt=&quot;그래프&quot; /&gt;
      &lt;/a&gt;
    
  
    
      &lt;a href=&quot;/assets/images/posts/image_matrix.png&quot; title=&quot;인접행렬&quot;&gt;
        &lt;img src=&quot;/assets/images/posts/image_matrix.png&quot; alt=&quot;인접행렬&quot; /&gt;
      &lt;/a&gt;
    
  
  
    &lt;figcaption&gt;
&lt;/figcaption&gt;
  
&lt;/figure&gt;

&lt;h3 id=&quot;주의&quot;&gt;주의&lt;/h3&gt;

&lt;p&gt;인접 리스트를 사용한 그래프 알고리즘들, 예를 들어 너비 우선 탐색 또한 인접 행렬에서 사용 가능하지만 효율성이 떨어진다. 인접 리스트에서는 어떤 노드에 인접한 노드를 쉽게 찾을 수 있지만, 모든 노드를 순회해야 알 수 있기 때문이다.&lt;/p&gt;

&lt;h2 id=&quot;그래프-탐색&quot;&gt;그래프 탐색&lt;/h2&gt;

&lt;p&gt;그래프를 탐색하는 방법은 두 가지로 깊이 우선 탐색(DFS: depth-first search), 너비 우선 탐색이(BFS: breadth-first search) 있다.&lt;/p&gt;

&lt;h3 id=&quot;깊이-우선-탐색depth-first-search&quot;&gt;깊이 우선 탐색(Depth first search)&lt;/h3&gt;

&lt;p&gt;깊이 우선 탐색은 임의의 노드(루트 노드)로 시작해서 인접 노드를 순회하기 전에, 방문한 노드가 가르키는 노드들을 먼저 순회하고 주변 노드들을 순회하는 방식이다. 한마디로 깊게(Deep) 순회를 시작한다.&lt;/p&gt;

&lt;h4 id=&quot;구현&quot;&gt;구현&lt;/h4&gt;

&lt;p&gt;전위순회를 포함한 다른 형태의 트리 순회는 모두 DFS의 한 종류이다. 이 알고리즘을 구현할 때 가장 큰 차이점은, 그래프 탐색의 경우 어떤 노드를 방문했었는지 체크해야 한다는 것이다. 체크하지 않는 경우 &lt;b&gt;무한루프&lt;/b&gt;에 빠지게 될 가능성이 높다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
        &lt;span class=&quot;nf&quot;&gt;visit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;forEach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nf&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;너비-우선-탐색breadth-first-search&quot;&gt;너비 우선 탐색(Breadth first search)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;특정 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때는 BFS가 일반적으로 더 낫다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;너비 우선 탐색은 임의의 노드(루트 노드)로 시작해서 인접 노드를 순회하면서 점점 깊게 들어간다. 한마디로 넓게(wide) 탐색한다는 말이다.&lt;/p&gt;

&lt;h4 id=&quot;구현-1&quot;&gt;구현&lt;/h4&gt;

&lt;p&gt;너비 우선 탐색은 일단 재귀적으로 동작하지 않는다. 큐를 사용해 루프 형태로 구현하는 것이 가장 잘 동작한다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;queue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;enqueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;isEmpty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;dequeue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;visit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;forEach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;enqueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;양방향-탐색&quot;&gt;양방향 탐색&lt;/h2&gt;

&lt;p&gt;양방향 탐색은 출발지와 도착지 사이에 최단 경로를 찾을 때 사용되곤 한다. 기본적으로 출발지와 도착지 두 노드에서 동시에 너비 우선 탐색을 수행한 뒤, 두 탐색 지점이 충돌하는 경우에 경로를 찾는 방식이다.&lt;/p&gt;

&lt;h2 id=&quot;그래프-구현&quot;&gt;그래프 구현&lt;/h2&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;data class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MutableList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;GraphNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;depthFirstSearch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;GraphNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;visit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;depth : $it&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isVisited&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;forEach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isVisited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;depthFirstSearch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;breathFirstSearch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;GraphNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;queue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;GraphNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isVisited&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;enqueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;isEmpty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;dequeue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;visit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;breath : $it&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;forEach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isVisited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isVisited&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;enqueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;visit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graphNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;GraphNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;GraphNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;graphNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;data class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;GraphNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MutableList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;GraphNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;mutableListOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;isVisited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;avatar&quot;=&gt;nil, &quot;bio&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;links&quot;=&gt;[{&quot;label&quot;=&gt;&quot;Email&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-envelope-square&quot;}, {&quot;label&quot;=&gt;&quot;Website&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-link&quot;}, {&quot;label&quot;=&gt;&quot;Twitter&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-twitter-square&quot;}, {&quot;label&quot;=&gt;&quot;Facebook&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-facebook-square&quot;}, {&quot;label&quot;=&gt;&quot;GitHub&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-github&quot;}, {&quot;label&quot;=&gt;&quot;Instagram&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-instagram&quot;}]}</name></author><category term="Datastructure" /><category term="Graph" /><summary type="html">그래프(Graph)</summary></entry></feed>