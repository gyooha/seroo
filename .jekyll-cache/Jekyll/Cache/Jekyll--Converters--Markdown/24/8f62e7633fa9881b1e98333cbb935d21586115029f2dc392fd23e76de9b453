I"q)<h1 id="그래프graph">그래프(Graph)</h1>

<p>그래프는 단순히 노드와 노드 사이를 연결한 것을 하나로 모아 놓은 것과 같다.</p>

<ul>
  <li>이전에 포스팅한 트리도 그래프의 한 종류이다. 하지만 그렇다고 모든 그래프가 트리인 것은 아니다. 간단히 말해서 트리는 사이클이 없는 하나의 연결 그래프이다.</li>
</ul>

<h2 id="그래프의-특징">그래프의 특징</h2>

<ul>
  <li>그래프는 방향성이 있을 수도 있고 없을 수도 있다.</li>
  <li>그래프는 여러 개의 고립된 부분 그래프(isolated subgraphs)로 구성될 수 있다. 모든 정점 쌍 간에 경로가 존재하는 그래프는 “연결 그래프” 라고 부른다.</li>
  <li>그래프는 사이클이 존재할 수도 있고, 존재하지 않을 수도 있다. 사이클이 없는 그래프는 “비순환 그래프(acycle graph)” 라고 부른다.</li>
</ul>

<figure class="half full">
  
    
      <a href="/assets/images/posts/image_graph_01.png" title="그래프 예제1">
        <img src="/assets/images/posts/image_graph_01.png" alt="그래프" />
      </a>
    
  
    
      <a href="/assets/images/posts/image_graph_02.png" title="그래프 예제2">
        <img src="/assets/images/posts/image_graph_02.png" alt="그래프" />
      </a>
    
  
  
    <figcaption>
</figcaption>
  
</figure>

<p>프로그래밍 관점에서 그래프를 표현할 때는 일반적으로 다음 두 가지 방법을 사용한다.</p>

<h2 id="인접-리스트adjacency-list">인접 리스트(adjacency list)</h2>

<p>인접 리스트는 그래프를 표현할 때 사용되는 가장 일반적인 방법이다. 모든 노드를 인접 리스트에 저장한다. 무방향 그래프에서 a, b 간선은 두 번 저장 된다. 한 번은 a 노드에 인접한 간선을 저장하고 다른 한번은 b에 인접한 간선을 저장한다.</p>

<p>간단하게 구현하면 아래와 같다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Graph</span><span class="p">(</span>
    <span class="kd">val</span> <span class="py">node</span><span class="p">:</span> <span class="nc">MutableList</span><span class="p">&lt;</span><span class="nc">Node</span><span class="p">&gt;</span>
<span class="p">)</span>

<span class="kd">data class</span> <span class="nc">Node</span><span class="p">&lt;</span><span class="nc">T</span><span class="p">&gt;(</span>
    <span class="kd">val</span> <span class="py">data</span><span class="p">:</span> <span class="nc">T</span><span class="p">,</span>
    <span class="kd">val</span> <span class="py">children</span><span class="p">:</span> <span class="nc">MutableList</span><span class="p">&lt;</span><span class="nc">Node</span><span class="p">&gt;</span>
<span class="p">)</span>
</code></pre></div></div>

<p>트리에서는 루트 노드에서 모든 노드를 접근할 수 있기 때문에, 트리 클래스를 따로 두지 않아도 됬었다. 하지만 그래프에서는 하나의 노드에서 모든 노드로 접근할 수 없기 때문에 Graph 클래스가 필요하다.</p>

<p>그래프를 표현하기 위한 추가적인 클래스를 따로 만들 필요는 없다. 배열 혹은 해시테이블과 해당 자료구조의 인덱스마다 존재하는 또 다른 리스트(배열, 가변리스트, 연결리스트)를 이용해서 인접 리스트를 표현할 수 있다.</p>

<p>위의 그림과 같은 그래프는 다음과 같이 표현할 수 있다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0: 1
1: 2
2: 0, 3
3: 2

4: 6
5: 4
6: 5
</code></pre></div></div>

<h2 id="인접-행렬">인접 행렬</h2>

<p>인접 행렬은 NXN Boolean 행렬로써 matrix[i][j]가 true라면 i에서 j로의 간선이 있다는 뜻이다. 0과 1을 이용한 정수 행렬을 사용할 수도 있다. 여기서 N은 노드의 개수를 의미한다.</p>

<p>무방향 그래프를 인접 행렬로 표현한다면 이 행렬은 대칭행렬이 된다. 방향 그래프에서는 대칭행렬이 안 될 수도 있다.</p>

<figure class="half full">
  
    
      <a href="/assets/images/posts/image_graph_02.png" title="그래프">
        <img src="/assets/images/posts/image_graph_02.png" alt="그래프" />
      </a>
    
  
    
      <a href="/assets/images/posts/image_matrix.png" title="인접행렬">
        <img src="/assets/images/posts/image_matrix.png" alt="인접행렬" />
      </a>
    
  
  
    <figcaption>
</figcaption>
  
</figure>

<h3 id="주의">주의</h3>

<p>인접 리스트를 사용한 그래프 알고리즘들, 예를 들어 너비 우선 탐색 또한 인접 행렬에서 사용 가능하지만 효율성이 떨어진다. 인접 리스트에서는 어떤 노드에 인접한 노드를 쉽게 찾을 수 있지만, 모든 노드를 순회해야 알 수 있기 때문이다.</p>

<h2 id="그래프-탐색">그래프 탐색</h2>

<p>그래프를 탐색하는 방법은 두 가지로 깊이 우선 탐색(DFS: depth-first search), 너비 우선 탐색이(BFS: breadth-first search) 있다.</p>

<h3 id="깊이-우선-탐색depth-first-search">깊이 우선 탐색(Depth first search)</h3>

<p>깊이 우선 탐색은 임의의 노드(루트 노드)로 시작해서 인접 노드를 순회하기 전에, 방문한 노드가 가르키는 노드들을 먼저 순회하고 주변 노드들을 순회하는 방식이다. 한마디로 깊게(Deep) 순회를 시작한다.</p>

<h4 id="구현">구현</h4>

<p>전위순회를 포함한 다른 형태의 트리 순회는 모두 DFS의 한 종류이다. 이 알고리즘을 구현할 때 가장 큰 차이점은, 그래프 탐색의 경우 어떤 노드를 방문했었는지 체크해야 한다는 것이다. 체크하지 않는 경우 <b>무한루프</b>에 빠지게 될 가능성이 높다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">search</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="nc">Node</span><span class="p">?)</span> <span class="p">{</span>
    <span class="n">root</span><span class="o">?.</span><span class="nf">let</span> <span class="p">{</span> 
        <span class="nf">visit</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
        <span class="n">it</span><span class="p">.</span><span class="n">visited</span> <span class="p">=</span> <span class="k">true</span>
        <span class="n">it</span><span class="p">.</span><span class="n">children</span><span class="p">.</span><span class="nf">forEach</span> <span class="p">{</span> <span class="n">node</span> <span class="p">-&gt;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">visited</span> <span class="p">==</span> <span class="k">false</span><span class="p">)</span> <span class="p">{</span>
                <span class="nf">search</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="너비-우선-탐색breadth-first-search">너비 우선 탐색(Breadth first search)</h3>

<ul>
  <li>특정 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때는 BFS가 일반적으로 더 낫다.</li>
</ul>

<p>너비 우선 탐색은 임의의 노드(루트 노드)로 시작해서 인접 노드를 순회하면서 점점 깊게 들어간다. 한마디로 넓게(wide) 탐색한다는 말이다.</p>

<h4 id="구현-1">구현</h4>

<p>너비 우선 탐색은 일단 재귀적으로 동작하지 않는다. 큐를 사용해 루프 형태로 구현하는 것이 가장 잘 동작한다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">search</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="nc">Node</span><span class="p">?)</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">queue</span> <span class="p">=</span> <span class="nc">Queue</span><span class="p">()</span>
    <span class="n">root</span><span class="o">?.</span><span class="n">visited</span> <span class="p">=</span> <span class="k">true</span>

    <span class="n">queue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

    <span class="k">while</span><span class="p">(!</span><span class="n">queue</span><span class="p">.</span><span class="nf">isEmpty</span><span class="p">())</span> <span class="p">{</span>
        <span class="kd">val</span> <span class="py">r</span> <span class="p">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
        <span class="nf">visit</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="n">r</span><span class="o">?.</span><span class="n">children</span><span class="o">?.</span><span class="nf">forEach</span> <span class="p">{</span> <span class="n">n</span> <span class="p">-&gt;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">visited</span> <span class="p">==</span> <span class="k">false</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">n</span><span class="p">.</span><span class="n">visited</span> <span class="p">=</span> <span class="k">true</span>
                <span class="n">queue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="양방향-탐색">양방향 탐색</h2>

<p>양방향 탐색은 출발지와 도착지 사이에 최단 경로를 찾을 때 사용되곤 한다. 기본적으로 출발지와 도착지 두 노드에서 동시에 너비 우선 탐색을 수행한 뒤, 두 탐색 지점이 충돌하는 경우에 경로를 찾는 방식이다.</p>

<h2 id="그래프-구현">그래프 구현</h2>

<p>추후 구현 예정</p>
:ET